<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://enderjs.com">ender (v2.1.1)</a>
</h1>
<h4>Open Module JavaScript Framework</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender">module ender</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.exec">
            function <span class="apidocSignatureSpan">ender.</span>exec
            <span class="apidocSignatureSpan">(argv, log, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package">
            function <span class="apidocSignatureSpan">ender.</span>local_package
            <span class="apidocSignatureSpan">(root)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>add</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>args_parser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>assemble</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>compile</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>errors</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>help</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>index</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>info</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>local_package.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>refresh</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>remove</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>search</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>version</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>vlq</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.add">module ender.add</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.add.exec">
            function <span class="apidocSignatureSpan">ender.add.</span>exec
            <span class="apidocSignatureSpan">(options, log, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.args_parser">module ender.args_parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.args_parser.extend">
            function <span class="apidocSignatureSpan">ender.args_parser.</span>extend
            <span class="apidocSignatureSpan">(originalArgs, newArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.args_parser.parse">
            function <span class="apidocSignatureSpan">ender.args_parser.</span>parse
            <span class="apidocSignatureSpan">(argv)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.args_parser.parseClean">
            function <span class="apidocSignatureSpan">ender.args_parser.</span>parseClean
            <span class="apidocSignatureSpan">(argv)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.args_parser.toContextString">
            function <span class="apidocSignatureSpan">ender.args_parser.</span>toContextString
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.assemble">module ender.assemble</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.assemble.assemble">
            function <span class="apidocSignatureSpan">ender.</span>assemble
            <span class="apidocSignatureSpan">(buildName, sourceMapName, options, packages, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.compile">module ender.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.compile.exec">
            function <span class="apidocSignatureSpan">ender.compile.</span>exec
            <span class="apidocSignatureSpan">(options, log, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.errors">module ender.errors</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.ArgumentParserError">
            function <span class="apidocSignatureSpan">ender.errors.</span>ArgumentParserError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.BuildError">
            function <span class="apidocSignatureSpan">ender.errors.</span>BuildError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.BuildParseError">
            function <span class="apidocSignatureSpan">ender.errors.</span>BuildParseError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.ChildProcessError">
            function <span class="apidocSignatureSpan">ender.errors.</span>ChildProcessError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.CommandError">
            function <span class="apidocSignatureSpan">ender.errors.</span>CommandError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.CompressionError">
            function <span class="apidocSignatureSpan">ender.errors.</span>CompressionError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.DependencyLoopError">
            function <span class="apidocSignatureSpan">ender.errors.</span>DependencyLoopError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.EnderError">
            function <span class="apidocSignatureSpan">ender.errors.</span>EnderError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.FilesystemError">
            function <span class="apidocSignatureSpan">ender.errors.</span>FilesystemError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.InstallError">
            function <span class="apidocSignatureSpan">ender.errors.</span>InstallError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.JSONParseError">
            function <span class="apidocSignatureSpan">ender.errors.</span>JSONParseError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.MinifyError">
            function <span class="apidocSignatureSpan">ender.errors.</span>MinifyError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.PackageError">
            function <span class="apidocSignatureSpan">ender.errors.</span>PackageError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.PackageNotFoundError">
            function <span class="apidocSignatureSpan">ender.errors.</span>PackageNotFoundError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.PackageNotLocalError">
            function <span class="apidocSignatureSpan">ender.errors.</span>PackageNotLocalError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.RepositoryCommandError">
            function <span class="apidocSignatureSpan">ender.errors.</span>RepositoryCommandError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.RepositoryError">
            function <span class="apidocSignatureSpan">ender.errors.</span>RepositoryError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.RepositorySetupError">
            function <span class="apidocSignatureSpan">ender.errors.</span>RepositorySetupError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.TemplateError">
            function <span class="apidocSignatureSpan">ender.errors.</span>TemplateError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.UnknownCommandError">
            function <span class="apidocSignatureSpan">ender.errors.</span>UnknownCommandError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.UnknownOptionError">
            function <span class="apidocSignatureSpan">ender.errors.</span>UnknownOptionError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.help">module ender.help</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.help.exec">
            function <span class="apidocSignatureSpan">ender.help.</span>exec
            <span class="apidocSignatureSpan">(options, log, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.index">module ender.index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.index.closure">
            function <span class="apidocSignatureSpan">ender.index.</span>closure
            <span class="apidocSignatureSpan">(files, filenames, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.index.uglify">
            function <span class="apidocSignatureSpan">ender.index.</span>uglify
            <span class="apidocSignatureSpan">(files, filenames, options, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.info">module ender.info</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.info.exec">
            function <span class="apidocSignatureSpan">ender.info.</span>exec
            <span class="apidocSignatureSpan">(options, log, callback, buildName, ids, files)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.local_package">module ender.local_package</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.local_package">
            function <span class="apidocSignatureSpan">ender.</span>local_package
            <span class="apidocSignatureSpan">(root)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.addPackageMapping">
            function <span class="apidocSignatureSpan">ender.local_package.</span>addPackageMapping
            <span class="apidocSignatureSpan">(id, root)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.buildTree">
            function <span class="apidocSignatureSpan">ender.local_package.</span>buildTree
            <span class="apidocSignatureSpan">(ids, pretty, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.createPackage">
            function <span class="apidocSignatureSpan">ender.local_package.</span>createPackage
            <span class="apidocSignatureSpan">(root)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.extendDescriptor">
            function <span class="apidocSignatureSpan">ender.local_package.</span>extendDescriptor
            <span class="apidocSignatureSpan">(descriptor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.findPackage">
            function <span class="apidocSignatureSpan">ender.local_package.</span>findPackage
            <span class="apidocSignatureSpan">(id, root, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.loadPackage">
            function <span class="apidocSignatureSpan">ender.local_package.</span>loadPackage
            <span class="apidocSignatureSpan">(root, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.unloadPackage">
            function <span class="apidocSignatureSpan">ender.local_package.</span>unloadPackage
            <span class="apidocSignatureSpan">(root)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.walkDependencies">
            function <span class="apidocSignatureSpan">ender.local_package.</span>walkDependencies
            <span class="apidocSignatureSpan">(ids, unique, strict, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.local_package.prototype">module ender.local_package.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.prototype.extendOptions">
            function <span class="apidocSignatureSpan">ender.local_package.prototype.</span>extendOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.prototype.loadDescriptor">
            function <span class="apidocSignatureSpan">ender.local_package.prototype.</span>loadDescriptor
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.prototype.loadSources">
            function <span class="apidocSignatureSpan">ender.local_package.prototype.</span>loadSources
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.prototype.unload">
            function <span class="apidocSignatureSpan">ender.local_package.prototype.</span>unload
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.refresh">module ender.refresh</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.refresh.exec">
            function <span class="apidocSignatureSpan">ender.refresh.</span>exec
            <span class="apidocSignatureSpan">(options, log, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.remove">module ender.remove</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.remove.exec">
            function <span class="apidocSignatureSpan">ender.remove.</span>exec
            <span class="apidocSignatureSpan">(options, log, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.search">module ender.search</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.search.exec">
            function <span class="apidocSignatureSpan">ender.search.</span>exec
            <span class="apidocSignatureSpan">(options, log, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.util">module ender.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.util.getCorePackages">
            function <span class="apidocSignatureSpan">ender.util.</span>getCorePackages
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.util.getInputFilenameFromOptions">
            function <span class="apidocSignatureSpan">ender.util.</span>getInputFilenameFromOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.util.packageList">
            function <span class="apidocSignatureSpan">ender.util.</span>packageList
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.util.parseContext">
            function <span class="apidocSignatureSpan">ender.util.</span>parseContext
            <span class="apidocSignatureSpan">(file, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.util.toKb">
            function <span class="apidocSignatureSpan">ender.util.</span>toKb
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.util.</span>defaultLogger</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.version">module ender.version</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.version.exec">
            function <span class="apidocSignatureSpan">ender.version.</span>exec
            <span class="apidocSignatureSpan">(options, log, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.vlq">module ender.vlq</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.vlq.decode">
            function <span class="apidocSignatureSpan">ender.vlq.</span>decode
            <span class="apidocSignatureSpan">(vlqstr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.vlq.encode">
            function <span class="apidocSignatureSpan">ender.vlq.</span>encode
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender" id="apidoc.module.ender">module ender</a></h1>


    <h2>
        <a href="#apidoc.element.ender.exec" id="apidoc.element.ender.exec">
        function <span class="apidocSignatureSpan">ender.</span>exec
        <span class="apidocSignatureSpan">(argv, log, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (argv, log, callback) {
  var parseType = 'parse'
    , options

    , complete = function (err) {
        if (err &amp;&amp; log) {
          var name = (err.name || 'Error').replace(/([a-z])([A-Z])/g, '$1 $2')

          log.error('{red}{bold}' + name + ': {/bold}' + err.message + '{/red}')

          if (options.debug) {
            log.error(err.stack)
            if (err.cause) log.error('Caused by:\n' + err.cause.stack)

          } else log.error('Run with --debug to see more information')
        }

        callback(err)
      }

  if (arguments.length &lt; 3) {
    callback = log
    log = undefined
  }

  if (typeof argv == 'string') {
    // for API use: ender.exec('ender &lt;cmd&gt;', cb)
    argv = argv.split(/\s/).slice(1)
    parseType = 'parseClean' // parseClean knows there aren't 2 preceeding tokens
  }

  try {
    options = argsParser[parseType](argv)
    require('./commands/' + options.command).exec(options, log, complete)
  } catch (ex) {
    options = options || { debug: argv.indexOf('--debug') != -1 }
    complete(ex)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


#!/usr/bin/env node

var main = require('../lib/main')
  , log  = require('../lib/util').defaultLogger

main.<span class="apidocCodeKeywordSpan">exec</span>(process.argv, log, function (err) {
  process.exit(err ? 1 : 0)
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package" id="apidoc.element.ender.local_package">
        function <span class="apidocSignatureSpan">ender.</span>local_package
        <span class="apidocSignatureSpan">(root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LocalPackage(root) {
  this.root = root

  // Memoize methods that hit the disk
  this.loadDescriptor = async.memoize(this.loadDescriptor.bind(this), unitaryHash)
  this.loadSources = async.memoize(this.loadSources.bind(this), unitaryHash)

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.add" id="apidoc.module.ender.add">module ender.add</a></h1>


    <h2>
        <a href="#apidoc.element.ender.add.exec" id="apidoc.element.ender.add.exec">
        function <span class="apidocSignatureSpan">ender.add.</span>exec
        <span class="apidocSignatureSpan">(options, log, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (options, log, callback) {
  var filename = util.getInputFilenameFromOptions(options)
; delete options.use // don't want --use showing up in the 'Build:' context string
  util.parseContext(filename, function (err, context) {
    if (!err) options = argsParser.extend(context.options, options)
    // merge commandline args with the build command in ender.js
    build.exec(options, log, callback)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


#!/usr/bin/env node

var main = require('../lib/main')
  , log  = require('../lib/util').defaultLogger

main.<span class="apidocCodeKeywordSpan">exec</span>(process.argv, log, function (err) {
  process.exit(err ? 1 : 0)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.args_parser" id="apidoc.module.ender.args_parser">module ender.args_parser</a></h1>


    <h2>
        <a href="#apidoc.element.ender.args_parser.extend" id="apidoc.element.ender.args_parser.extend">
        function <span class="apidocSignatureSpan">ender.args_parser.</span>extend
        <span class="apidocSignatureSpan">(originalArgs, newArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (originalArgs, newArgs) {
  return parse(toContextString(newArgs).split(' '), 1, originalArgs)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  , util         = require('../util')
  , build        = require('./build')

  , exec = function (options, log, callback) {
      var filename = util.getInputFilenameFromOptions(options)
    ; delete options.use // don't want --use showing up in the 'Build:' context string
      util.parseContext(filename, function (err, context) {
        if (!err) options = argsParser.<span class="apidocCodeKeywordSpan">extend</span>(context.options, options)
        // merge commandline args with the build command in ender.js
        build.exec(options, log, callback)
      })
    }

module.exports.exec = exec
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.args_parser.parse" id="apidoc.element.ender.args_parser.parse">
        function <span class="apidocSignatureSpan">ender.args_parser.</span>parse
        <span class="apidocSignatureSpan">(argv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (argv) { return parse(argv, 2) }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  , loadDescriptor: function (callback) {
      var descriptorPath = repository.util.getPackageDescriptor(this.root)

      fs.readFile(descriptorPath, 'utf-8', function (err, data) {
if (err) return callback(new FilesystemError(err))

try {
  data = JSON.<span class="apidocCodeKeywordSpan">parse</span>(data)
} catch (err) {
  return callback(new JSONParseError(err.message + ' [' + descriptorPath + ']', err))
}

this.descriptor = LocalPackage.extendDescriptor(data)
this.name = this.descriptor.name
this.version = this.descriptor.version || ''
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.args_parser.parseClean" id="apidoc.element.ender.args_parser.parseClean">
        function <span class="apidocSignatureSpan">ender.args_parser.</span>parseClean
        <span class="apidocSignatureSpan">(argv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseClean = function (argv) { return parse(argv, 0) }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (!match) {
  error = 'Could not parse ender spec from "' + file + '" (not an Ender build file?)'
  return callback(new BuildParseError(error))
}

try {
  options = argsParser.<span class="apidocCodeKeywordSpan">parseClean</span>(match[1].split(' '))
} catch (ex) {
  error = 'Could not parse ender spec from "' + file + '"'
  return callback(new BuildParseError(error, ex))
}

callback(null, {
    options  : options
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.args_parser.toContextString" id="apidoc.element.ender.args_parser.toContextString">
        function <span class="apidocSignatureSpan">ender.args_parser.</span>toContextString
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toContextString = function (options) {
  var str = options.command
    , p

  if (options.packages.length) str += ' ' + options.packages.join(' ')

  for (p in options) {
    if (p === 'packages' || p === 'command') continue
    str += ' --' + p
    if (Array.isArray(options[p])) str += ' ' + options[p].join(' ')
    else if (typeof options[p] !== 'boolean') str += ' ' + options[p]
  }
  return str
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return str &amp;&amp; str.replace(/^/mg, Array(spaces+1).join(' '))
    }

  , assemble = function (buildName, sourceMapName, options, packages, callback) {
      var templateData = {
      buildName: buildName
    , sourceMapName: sourceMapName
    , context: argsParser.<span class="apidocCodeKeywordSpan">toContextString</span>(options)
    , packageList: []
    , packages: []
  }

, sourceIndex = 0
, sourceLine = 0
, sourceNames = []
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.assemble" id="apidoc.module.ender.assemble">module ender.assemble</a></h1>


    <h2>
        <a href="#apidoc.element.ender.assemble.assemble" id="apidoc.element.ender.assemble.assemble">
        function <span class="apidocSignatureSpan">ender.</span>assemble
        <span class="apidocSignatureSpan">(buildName, sourceMapName, options, packages, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assemble = function (buildName, sourceMapName, options, packages, callback) {
  var templateData = {
          buildName: buildName
        , sourceMapName: sourceMapName
        , context: argsParser.toContextString(options)
        , packageList: []
        , packages: []
      }

    , sourceIndex = 0
    , sourceLine = 0
    , sourceNames = []
    , generateMappings = function (name, content, indent, inline) {
        if (sourceNames.indexOf(name) == -1) sourceNames.push(name)

        return content.replace(/^.*$(\r\n|\r|\n)?/mg, function (line, ending, offset) {
          var firstLine = !offset
            , sourceIndexDelta = (firstLine ? sourceNames.indexOf(name) - sourceIndex : 0)
            , sourceLineDelta = (firstLine ? -sourceLine : 1)

          if (!line.length) return ''

          sourceIndex += sourceIndexDelta
          sourceLine += sourceLineDelta

          return (
            vlq.encode(indent || 0) +                                     // Adjust for indent
            vlq.encode(sourceIndexDelta) +                                // Set the source index
            vlq.encode(sourceLineDelta) +                                 // Set the source line
            vlq.encode(0) +                                               // Source column (always 0)
            (ending ? ';' : '')                                           // Did we have a line ending?
          )
        })
      }

  packages.forEach(function (pkg) {
    templateData.packageList.push(pkg.id)

    // are we autointegrating this package?
    if (!pkg.bridge &amp;&amp; Array.isArray(options.integrate) &amp;&amp; options.integrate.indexOf(pkg.name) != -1) {
      pkg.sources.push({ name: 'bridge', content: generateDefaultBridge(pkg.name) })
      pkg.bridge = 'bridge'
    }

    if (pkg.sources.length) {
      var pkgData = {
              isBare: pkg.bare
            , isExposed: pkg.bare

            , name: pkg.name
            , main: pkg.main
            , bridge: pkg.bridge
            , sources: []
          }

        , relativeRoot = path.relative('.', pkg.root)

      // do we have a sandboxed build?
      if (Array.isArray(options.sandbox)) {
        pkgData.isExposed = (options.sandbox.indexOf(pkg.name) != -1)
      }

      pkg.sources.forEach(function (source, i) {
        var indent = pkg.bare ? 2 : 6
          , indentedContent = indentLines(source.content, indent)

        // check if this is the bridge and we want to exclude it from the build
        if (pkg.bare &amp;&amp; !pkgData.isExposed &amp;&amp; source.name == pkg.bridge) {
          delete pkgData.bridge
          return
        }

        pkgData.sources.push({
            i: i
          , name: source.name
          , content: indentedContent
          , mappings: generateMappings(path.join(relativeRoot, source.name + '.js'), source.content, indent)
        })
      })

      templateData.packages.push(pkgData)
    }
  })

  templateData.packageList = templateData.packageList.join(' ')
  templateData.sourceList = JSON.stringify(sourceNames)

  async.parallel({
      build: function (callback) {
        var source = ''
        mu.compileAndRender('build.mustache', templateData)
          .on('error', function (err) { callback(new TemplateError(err)) })
          .on('data', function (data) { source += data })
          .on('end', function () { callback(null, source) })
      }

    , sourceMap: function (callback) {
        var sourceMap = ''
        mu.compileAndRender('build.map.mustache', templateData)
          .on('error', function (err) { callback(new TemplateError(err)) })
          .on('data', function (data) { sourceMap += data })
          .on('end', function () { callback(null, sourceMap) })
      }
  }, callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (!minifier) return new MinifyError('No such minifier: "' + options.minifier + '"')

      packages.forEach(function (pkg) { pkg.extendOptions(extendedOptions) })
      minifier(files, filenames, extendedOptions, callback)
    }

  , assembleBuild = function (callback) {
      assemble.<span class="apidocCodeKeywordSpan">assemble</span>(filenames.build, filenames.sourceMap, options, packages, callback
)
    }

  , loadSources = function (callback) {
      async.each(packages, function (pkg, callback) { pkg.loadSources(callback) }, callback)
    }

async.waterfall([
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.compile" id="apidoc.module.ender.compile">module ender.compile</a></h1>


    <h2>
        <a href="#apidoc.element.ender.compile.exec" id="apidoc.element.ender.compile.exec">
        function <span class="apidocSignatureSpan">ender.compile.</span>exec
        <span class="apidocSignatureSpan">(options, log, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (options, log, callback) {
  var outfile

  if (arguments.length &lt; 3) {
    callback = log
    log = undefined
  }

  if (log) log.info('Running Closure Compiler...')

  async.waterfall([
      function (callback) {
        closure(options, function (err, file) {
          if (err) return callback(err) // wrapped in closure()
          callback(null, outfile = file)
        })
      }
    , function (file, callback) {
        fs.readFile(file, 'utf-8', function (err, data) {
          if (err) return callback(new FilesystemError(err))
          callback(null, data)
        })
      }
    , function (raw, callback) {
        zlib.gzip(raw, function (err, gzipped) {
          if (err) return callback(new CompressionError(err))
          callback(null, raw, gzipped)
        })
      }
    , function (raw, gzipped, callback) {
        if (log) log.info('Success! Your compiled source is {cyan}' + util.toKb(raw.length) + '{/cyan} minified' +
                          ' and {cyan}' + util.toKb(gzipped.length) + '{/cyan} gzipped' +
                          ' and is available at {green}' + outfile.green + '{/green}')

        callback()
      }
  ], callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


#!/usr/bin/env node

var main = require('../lib/main')
  , log  = require('../lib/util').defaultLogger

main.<span class="apidocCodeKeywordSpan">exec</span>(process.argv, log, function (err) {
  process.exit(err ? 1 : 0)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.errors" id="apidoc.module.ender.errors">module ender.errors</a></h1>


    <h2>
        <a href="#apidoc.element.ender.errors.ArgumentParserError" id="apidoc.element.ender.errors.ArgumentParserError">
        function <span class="apidocSignatureSpan">ender.errors.</span>ArgumentParserError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ArgumentParserError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == 'FilesystemError') {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? ' [' + this.cause.path + ']' : '')
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.BuildError" id="apidoc.element.ender.errors.BuildError">
        function <span class="apidocSignatureSpan">ender.errors.</span>BuildError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BuildError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == 'FilesystemError') {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? ' [' + this.cause.path + ']' : '')
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.BuildParseError" id="apidoc.element.ender.errors.BuildParseError">
        function <span class="apidocSignatureSpan">ender.errors.</span>BuildParseError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BuildParseError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == 'FilesystemError') {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? ' [' + this.cause.path + ']' : '')
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.ChildProcessError" id="apidoc.element.ender.errors.ChildProcessError">
        function <span class="apidocSignatureSpan">ender.errors.</span>ChildProcessError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ChildProcessError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == 'FilesystemError') {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? ' [' + this.cause.path + ']' : '')
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.CommandError" id="apidoc.element.ender.errors.CommandError">
        function <span class="apidocSignatureSpan">ender.errors.</span>CommandError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CommandError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == 'FilesystemError') {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? ' [' + this.cause.path + ']' : '')
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.CompressionError" id="apidoc.element.ender.errors.CompressionError">
        function <span class="apidocSignatureSpan">ender.errors.</span>CompressionError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CompressionError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == 'FilesystemError') {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? ' [' + this.cause.path + ']' : '')
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.DependencyLoopError" id="apidoc.element.ender.errors.DependencyLoopError">
        function <span class="apidocSignatureSpan">ender.errors.</span>DependencyLoopError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DependencyLoopError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == 'FilesystemError') {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? ' [' + this.cause.path + ']' : '')
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.EnderError" id="apidoc.element.ender.errors.EnderError">
        function <span class="apidocSignatureSpan">ender.errors.</span>EnderError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">EnderError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == 'FilesystemError') {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? ' [' + this.cause.path + ']' : '')
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.FilesystemError" id="apidoc.element.ender.errors.FilesystemError">
        function <span class="apidocSignatureSpan">ender.errors.</span>FilesystemError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FilesystemError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == 'FilesystemError') {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? ' [' + this.cause.path + ']' : '')
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.InstallError" id="apidoc.element.ender.errors.InstallError">
        function <span class="apidocSignatureSpan">ender.errors.</span>InstallError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">InstallError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == 'FilesystemError') {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? ' [' + this.cause.path + ']' : '')
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.JSONParseError" id="apidoc.element.ender.errors.JSONParseError">
        function <span class="apidocSignatureSpan">ender.errors.</span>JSONParseError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JSONParseError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == 'FilesystemError') {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? ' [' + this.cause.path + ']' : '')
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.MinifyError" id="apidoc.element.ender.errors.MinifyError">
        function <span class="apidocSignatureSpan">ender.errors.</span>MinifyError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MinifyError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == 'FilesystemError') {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? ' [' + this.cause.path + ']' : '')
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.PackageError" id="apidoc.element.ender.errors.PackageError">
        function <span class="apidocSignatureSpan">ender.errors.</span>PackageError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PackageError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == 'FilesystemError') {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? ' [' + this.cause.path + ']' : '')
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.PackageNotFoundError" id="apidoc.element.ender.errors.PackageNotFoundError">
        function <span class="apidocSignatureSpan">ender.errors.</span>PackageNotFoundError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PackageNotFoundError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == 'FilesystemError') {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? ' [' + this.cause.path + ']' : '')
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.PackageNotLocalError" id="apidoc.element.ender.errors.PackageNotLocalError">
        function <span class="apidocSignatureSpan">ender.errors.</span>PackageNotLocalError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PackageNotLocalError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == 'FilesystemError') {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? ' [' + this.cause.path + ']' : '')
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.RepositoryCommandError" id="apidoc.element.ender.errors.RepositoryCommandError">
        function <span class="apidocSignatureSpan">ender.errors.</span>RepositoryCommandError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RepositoryCommandError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == 'FilesystemError') {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? ' [' + this.cause.path + ']' : '')
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.RepositoryError" id="apidoc.element.ender.errors.RepositoryError">
        function <span class="apidocSignatureSpan">ender.errors.</span>RepositoryError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RepositoryError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == 'FilesystemError') {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? ' [' + this.cause.path + ']' : '')
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.RepositorySetupError" id="apidoc.element.ender.errors.RepositorySetupError">
        function <span class="apidocSignatureSpan">ender.errors.</span>RepositorySetupError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RepositorySetupError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == 'FilesystemError') {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? ' [' + this.cause.path + ']' : '')
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.TemplateError" id="apidoc.element.ender.errors.TemplateError">
        function <span class="apidocSignatureSpan">ender.errors.</span>TemplateError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TemplateError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == 'FilesystemError') {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? ' [' + this.cause.path + ']' : '')
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.UnknownCommandError" id="apidoc.element.ender.errors.UnknownCommandError">
        function <span class="apidocSignatureSpan">ender.errors.</span>UnknownCommandError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">UnknownCommandError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == 'FilesystemError') {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? ' [' + this.cause.path + ']' : '')
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.UnknownOptionError" id="apidoc.element.ender.errors.UnknownOptionError">
        function <span class="apidocSignatureSpan">ender.errors.</span>UnknownOptionError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">UnknownOptionError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == 'FilesystemError') {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? ' [' + this.cause.path + ']' : '')
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.help" id="apidoc.module.ender.help">module ender.help</a></h1>


    <h2>
        <a href="#apidoc.element.ender.help.exec" id="apidoc.element.ender.help.exec">
        function <span class="apidocSignatureSpan">ender.help.</span>exec
        <span class="apidocSignatureSpan">(options, log, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (options, log, callback) {
  var page = options.packages[0] || 'main'
    , file

  if (arguments.length &lt; 3) {
    callback = log
    log = undefined
  }

  if (!log) return callback()

  page = page.toLowerCase().replace(/[^a-z]/g,'')
  page = aliases[page] || page
  file = path.join(templateDirectory, page + '.tmpl')

  fs.exists(file, function (exists) {
    if (exists) {
      fs.readFile(file, 'utf-8', function (err, template) {
        if (err) return callback(new FilesystemError(err))
        log.info(template)
        callback()
      })
    } else {
      log.warn('No such command: {yellow}' + page + '{/yellow}\n' +
               'Use {cyan}ender help{/cyan} to show a summary of basic commands')

      callback()
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


#!/usr/bin/env node

var main = require('../lib/main')
  , log  = require('../lib/util').defaultLogger

main.<span class="apidocCodeKeywordSpan">exec</span>(process.argv, log, function (err) {
  process.exit(err ? 1 : 0)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.index" id="apidoc.module.ender.index">module ender.index</a></h1>


    <h2>
        <a href="#apidoc.element.ender.index.closure" id="apidoc.element.ender.index.closure">
        function <span class="apidocSignatureSpan">ender.index.</span>closure
        <span class="apidocSignatureSpan">(files, filenames, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closure = function (files, filenames, options, callback) {
  var comments  = []
    , stdin     = files.build.replace(reMultiComments, function(full, comment) {
                    comments.push(comment)
                    return '/** @preserve ' + token + '*/'
                  })
    , stdout    = ''
    , stderr    = ''
    , javaArgs  = ['-jar', jarPath]
    , child

  if (levels.hasOwnProperty(options.level))
    javaArgs.push('--compilation_level=' + levels[options.level])

  if (filenames.minifiedSourceMap)
    javaArgs.push('--create_source_map=' + filenames.minifiedSourceMap)

  if (options.externs)
    javaArgs.concat(options.externs.map(function (e) { return '--externs=' + e }))

  child = childProcess.spawn(javaCmd, javaArgs)

  child.stdout.on('data', function (data) {
    stdout += data.toString('utf-8')
  })

  child.stderr.on('data', function (data) {
    stderr += data.toString('utf-8')
  })

  child.on('exit', function (code, signal) {
    var err
    if (code !== 0) {
      err = new MinifyError('Child process exited on signal: ' + signal)
      err.stderr = stderr
      return callback(err)
    }
    stdout = stdout.replace(reTokens, function() {
      return '\n' + comments.shift().replace(/(^[\n\s]+)|([\n\s]+$)/g, '')
    })

    files.minifiedBuild = stdout
    callback(null, files)
  })

  child.stdin.write(stdin, 'utf-8')
  child.stdin.end()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.index.uglify" id="apidoc.element.ender.index.uglify">
        function <span class="apidocSignatureSpan">ender.index.</span>uglify
        <span class="apidocSignatureSpan">(files, filenames, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uglify = function (files, filenames, options, callback) {
    try {
      var ast = UglifyJS.parse(files.build, { filename: filenames.build })
        , sourceMap = UglifyJS.SourceMap({ file: filenames.minifiedBuild, orig: files.sourceMap })
        , compressor = UglifyJS.Compressor()
        , minifiedBuild

      // Supress warnings (mainly to prevent extraneous SourceMap warnings)
      UglifyJS.AST_Node.warn_function = null

      ast.figure_out_scope()
      ast = ast.transform(compressor)
      ast.figure_out_scope()
      ast.compute_char_frequency()
      ast.mangle_names()

      files.minifiedBuild = ast.print_to_string({
          source_map: sourceMap
        , comments: function (node, comment) {
            return comment.type == "comment2" &amp;&amp; /^!|@preserve|@license|@cc_on/i.test(comment.value)
          }
      })

      files.minifiedSourceMap = sourceMap.toString()
      callback(null, files)

    } catch (ex) {
      var err = new MinifyError('Uglify error')
      err.cause = ex
      return callback(err)
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.info" id="apidoc.module.ender.info">module ender.info</a></h1>


    <h2>
        <a href="#apidoc.element.ender.info.exec" id="apidoc.element.ender.info.exec">
        function <span class="apidocSignatureSpan">ender.info.</span>exec
        <span class="apidocSignatureSpan">(options, log, callback, buildName, ids, files)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (options, log, callback, buildName, ids, files) {
  var sizes = {}

    , finish = function (callback) {

        log.info('Your current build command is: {yellow}ender ' + argsParser.toContextString(options) + '{/yellow}')
        log.info(
          'Your current build size is: {yellow}' + util.toKb(sizes.build) + '{/yellow} raw' +
          (sizes.minifiedBuild ?
              ', {yellow}' + util.toKb(sizes.minifiedBuild) + '{/yellow} minified' +
              ' and {yellow}' + util.toKb(sizes.gzippedMinifiedBuild) + '{/yellow} gzipped'
            : '')
          + '\n')

        LocalPackage.buildTree(ids, true, function (err, tree) {
          if (err) return callback(err)
          log.info(tree)
          callback()
        })
      }

    , calculateSizes = function (callback) {
        sizes.build = files.build.length

        if (!files.minifiedBuild) return callback()
        sizes.minifiedBuild = files.minifiedBuild.length

        zlib.gzip(files.minifiedBuild, function (err, data) {
          if (err) return callback(new CompressionError(err))

          sizes.gzippedMinifiedBuild = data.length
          callback()
        })
      }

    , loadFiles = function (callback) {
        if (files) return callback()

        var tasks = {}

        tasks.build = fs.readFile.bind(null, buildName, 'utf-8')

        if (options.minifier != 'none') {
          tasks.minifiedBuild = fs.readFile.bind(null, buildName.replace(/\.js$/, '.min.js'), 'utf-8')
        }

        async.parallel(tasks, function (err, _files) {
          if (err) return callback(new FilesystemError(err))
          files = _files
          callback()
        })
      }

    , loadOptions = function (callback) {
        // If we're the main command, we need to load things from the build
        if (!buildName) {
          buildName = util.getInputFilenameFromOptions(options)
          options = null
        }

        if (options &amp;&amp; ids) return callback()

        // read 'Build: ...' and 'Packages: ...' from the head of the build file
        util.parseContext(buildName, function (err, context) {
          if (err) return callback(err)
          options = context.options

          if (!ids) ids = util.packageList(options)
          callback()
        })
      }

  if (arguments.length &lt; 3) {
    callback = log
    log = undefined
  }

  if (!log) return callback()

  async.series(
      [
          loadOptions
        , loadFiles
        , calculateSizes
        , finish
      ]
    , callback
  )
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


#!/usr/bin/env node

var main = require('../lib/main')
  , log  = require('../lib/util').defaultLogger

main.<span class="apidocCodeKeywordSpan">exec</span>(process.argv, log, function (err) {
  process.exit(err ? 1 : 0)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.local_package" id="apidoc.module.ender.local_package">module ender.local_package</a></h1>


    <h2>
        <a href="#apidoc.element.ender.local_package.local_package" id="apidoc.element.ender.local_package.local_package">
        function <span class="apidocSignatureSpan">ender.</span>local_package
        <span class="apidocSignatureSpan">(root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LocalPackage(root) {
  this.root = root

  // Memoize methods that hit the disk
  this.loadDescriptor = async.memoize(this.loadDescriptor.bind(this), unitaryHash)
  this.loadSources = async.memoize(this.loadSources.bind(this), unitaryHash)

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package.addPackageMapping" id="apidoc.element.ender.local_package.addPackageMapping">
        function <span class="apidocSignatureSpan">ender.local_package.</span>addPackageMapping
        <span class="apidocSignatureSpan">(id, root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addPackageMapping = function (id, root) {
  packageMappings[id] = root
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    repository.install(idsToInstall, function (err, receipts) {
      if (err) return callback(err) // wrapped in ender-repository

      // Unmemoize all the packages we just installed
      receipts.forEach(function (receipt) {
        installedIds.push(receipt.id)
        LocalPackage.unloadPackage(receipt.root)
        LocalPackage.<span class="apidocCodeKeywordSpan">addPackageMapping</span>(receipt.source, receipt.root)
      })

      callback(null, receipts)
    })
  }

, installRest = function (callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package.buildTree" id="apidoc.element.ender.local_package.buildTree">
        function <span class="apidocSignatureSpan">ender.local_package.</span>buildTree
        <span class="apidocSignatureSpan">(ids, pretty, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildTree = function (ids, pretty, callback) {
  var seenRoots = []

    , processId = function (id, root, callback) {
        LocalPackage.findPackage(id, root, function (err, dep) {
          if (err) return callback(err)
          processPackage(dep, callback)
        })
      }

    , processPackage = function (pkg, callback) {
        var node = {}
          , first = seenRoots.indexOf(pkg.root) == -1

        seenRoots.push(pkg.root)

        if (pretty) {
          if (first) {
            node.label = '{yellow}' + pkg.name + '@' + pkg.version + '{/yellow}{white} - ' + pkg.description + '{/white}'
          } else {
            node.label = '{grey}' + pkg.name + '@' + pkg.version + ' - ' + pkg.description + '{/grey}'
          }
        } else {
          node.label = pkg.name + '@' + pkg.version
        }

        async.map(
            pkg.dependencies
          , function (id, callback) { processId(id, pkg.root, callback) }
          , function (err, nodes) {
            if (err) return callback(err)
            node.nodes = nodes
            callback(null, node)
          }
        )
      }

  async.map(
      ids
    , function (id, callback) { processId(id, '.', callback) }
    , function (err, nodes) {
        if (err) return callback(err)

        var archyTree = {
                label: 'Active packages:'
              , nodes: nodes
            }

        callback(null, archy(archyTree))
      }
  )
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      'Your current build size is: {yellow}' + util.toKb(sizes.build) + '{/yellow} raw' +
      (sizes.minifiedBuild ?
          ', {yellow}' + util.toKb(sizes.minifiedBuild) + '{/yellow} minified' +
          ' and {yellow}' + util.toKb(sizes.gzippedMinifiedBuild) + '{/yellow} gzipped'
        : '')
      + '\n')

    LocalPackage.<span class="apidocCodeKeywordSpan">buildTree</span>(ids, true, function (err, tree) {
      if (err) return callback(err)
      log.info(tree)
      callback()
    })
  }

, calculateSizes = function (callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package.createPackage" id="apidoc.element.ender.local_package.createPackage">
        function <span class="apidocSignatureSpan">ender.local_package.</span>createPackage
        <span class="apidocSignatureSpan">(root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createPackage = function (root) {
  root = path.resolve(root)
  return packageCache[root] || (packageCache[root] = new LocalPackage(root))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
extend(LocalPackage, {
  createPackage: function (root) {
    root = path.resolve(root)
    return packageCache[root] || (packageCache[root] = new LocalPackage(root))
  }

, loadPackage: function (root, callback) {
    var pkg = LocalPackage.<span class="apidocCodeKeywordSpan">createPackage</span>(root)
    pkg.loadDescriptor(function (err) {
      if (err) return callback(err)
      callback(null, pkg)
    })
  }

, unloadPackage: function (root) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package.extendDescriptor" id="apidoc.element.ender.local_package.extendDescriptor">
        function <span class="apidocSignatureSpan">ender.local_package.</span>extendDescriptor
        <span class="apidocSignatureSpan">(descriptor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extendDescriptor = function (descriptor) {
  var overrides = ['bare', 'name', 'files', 'main', 'bridge', 'dependencies', 'devDependencies']
    , newDescriptor = Object.create(descriptor) // original is available via Object.getPrototypeOf
    , key

  if (typeof descriptor.overlay == 'object' &amp;&amp;
      typeof descriptor.overlay.ender == 'object') {
    overrides.forEach(function (key) {
      if (key in descriptor.overlay.ender) {
        newDescriptor[key] = descriptor.overlay.ender[key]
      }
    })
  }

  if (descriptor.ender == 'noop') {
    newDescriptor.ender = null

  } else if (typeof descriptor.ender == 'string') {
    newDescriptor.bridge = descriptor.ender

  } else if (typeof descriptor.ender == 'object') {
    overrides.forEach(function (key) {
      if (key in descriptor.ender) {
        newDescriptor[key] = descriptor.ender[key]
      }
    })
  }

  return newDescriptor
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  try {
    data = JSON.parse(data)
  } catch (err) {
    return callback(new JSONParseError(err.message + ' [' + descriptorPath + ']', err))
  }

  this.descriptor = LocalPackage.<span class="apidocCodeKeywordSpan">extendDescriptor</span>(data)
  this.name = this.descriptor.name
  this.version = this.descriptor.version || ''
  this.description = this.descriptor.description || ''
  this.bare = !!this.descriptor.bare

  callback()
}.bind(this))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package.findPackage" id="apidoc.element.ender.local_package.findPackage">
        function <span class="apidocSignatureSpan">ender.local_package.</span>findPackage
        <span class="apidocSignatureSpan">(id, root, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findPackage = function (id, root, callback) {
  var name = repository.util.getName(id)
    , version = repository.util.getVersion(id)
    , nameType = repository.util.getNameType(name)
    , matches = function (pkg) {
        return (pkg &amp;&amp;
                (nameType == 'path' || pkg.originalName == name) &amp;&amp;
                semver.satisfies(pkg.version, version))
      }

  root = path.resolve(root)

  // See if we've mapped this package id to a local package
  if (id in packageMappings) {
    name = packageMappings[id]
    nameType = 'path'
  }

  switch (nameType) {
    case 'path':
      LocalPackage.loadPackage(name, function (err, pkg) {
        if (matches(pkg)) return callback(null, pkg)
        return callback(new PackageNotFoundError("Package at '" + name + "' does not satisfy version '" + version + "'."))
      })
      break

    case 'package':
      // Don't search above the CWD
      if (/^\.\./.test(path.relative('.', root)))
        return callback(new PackageNotFoundError("Package '" + id + "' could not be found."))

      LocalPackage.loadPackage(root, function (err, pkg) {
        if (matches(pkg)) return callback(null, pkg)

        LocalPackage.loadPackage(repository.util.getChildRoot(name, root), function (err, pkg) {
          if (matches(pkg)) return callback(null, pkg)

          LocalPackage.findPackage(id, path.dirname(root), callback)
        })
      })
      break

    case 'tarball':
    case 'url':
    case 'git':
    case 'github':
      callback(new PackageNotLocalError('Can only find packages by path or name'))
      break
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  LocalPackage.loadPackage(root, function (err, pkg) {
    if (matches(pkg)) return callback(null, pkg)

    LocalPackage.loadPackage(repository.util.getChildRoot(name, root), function (err, pkg) {
      if (matches(pkg)) return callback(null, pkg)

      LocalPackage.<span class="apidocCodeKeywordSpan">findPackage</span>(id, path.dirname(root), callback)
    })
  })
  break

case 'tarball':
case 'url':
case 'git':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package.loadPackage" id="apidoc.element.ender.local_package.loadPackage">
        function <span class="apidocSignatureSpan">ender.local_package.</span>loadPackage
        <span class="apidocSignatureSpan">(root, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadPackage = function (root, callback) {
  var pkg = LocalPackage.createPackage(root)
  pkg.loadDescriptor(function (err) {
    if (err) return callback(err)
    callback(null, pkg)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (id in packageMappings) {
name = packageMappings[id]
nameType = 'path'
      }

      switch (nameType) {
case 'path':
  LocalPackage.<span class="apidocCodeKeywordSpan">loadPackage</span>(name, function (err, pkg) {
    if (matches(pkg)) return callback(null, pkg)
    return callback(new PackageNotFoundError("Package at '" + name + "' does not satisfy version '&amp;#
x22; + version + "'."))
  })
  break

case 'package':
  // Don't search above the CWD
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package.unloadPackage" id="apidoc.element.ender.local_package.unloadPackage">
        function <span class="apidocSignatureSpan">ender.local_package.</span>unloadPackage
        <span class="apidocSignatureSpan">(root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unloadPackage = function (root) {
  LocalPackage.createPackage(root).unload()

  for (var key in packageMappings)
    if (packageMappings[key] == root)
      delete packageMappings[key]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        , install = function (idsToInstall, callback) {
  repository.install(idsToInstall, function (err, receipts) {
    if (err) return callback(err) // wrapped in ender-repository

    // Unmemoize all the packages we just installed
    receipts.forEach(function (receipt) {
      installedIds.push(receipt.id)
      LocalPackage.<span class="apidocCodeKeywordSpan">unloadPackage</span>(receipt.root)
      LocalPackage.addPackageMapping(receipt.source, receipt.root)
    })

    callback(null, receipts)
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package.walkDependencies" id="apidoc.element.ender.local_package.walkDependencies">
        function <span class="apidocSignatureSpan">ender.local_package.</span>walkDependencies
        <span class="apidocSignatureSpan">(ids, unique, strict, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">walkDependencies = function (ids, unique, strict, callback) {
  var packages = []
    , missing = []
    , seenNames = []
    , seenRoots = []

    , processId = function (id, root, callback) {
        LocalPackage.findPackage(id, root, function (err, pkg) {
          if (err) {
            if (strict) return callback(err)

            missing.push(id)
            return callback()
          }

          processPackage(pkg, callback)
        })
      }

    , processPackage = function (pkg, callback) {
        if (seenRoots.indexOf(pkg.root) != -1) return callback()
        seenRoots.push(pkg.root)

        async.map(
            pkg.dependencies
          , function (id, callback) { processId(id, pkg.root, callback) }
          , function (err) {
              if (err) return callback(err)
              packages.push(pkg)
              seenNames.push(pkg.originalName)
              callback()
          }
        )
      }

  async.map(
      ids
    , function (id, callback) { processId(id, '.', callback) }
    , function (err) {
        if (err) return callback(err)

        if (unique) {
          // Return only the first package if we found multiple instances
          packages = packages.filter(function (p, i) { return seenNames.indexOf(p.originalName) == i })
          missing = missing.filter(function (n, i) { return missing.indexOf(n) == i })
        }

        callback(null, packages, missing)
      }
  )
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    })
  }
, callback
            )
          }

        , updateMissing = function (callback) {
            LocalPackage.<span class="apidocCodeKeywordSpan">walkDependencies</span>(ids, true, false, function (err, packages,
_missing) {
if (err) return callback(err) // this should never happen if we don't request `strict`

missing = _missing
var dupes = missing.filter(function (id) { return installedIds.indexOf(id) != -1 })
if (dupes.length)
  return callback(new DependencyLoopError('Installing identical package twice: ' + dupes))
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.local_package.prototype" id="apidoc.module.ender.local_package.prototype">module ender.local_package.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ender.local_package.prototype.extendOptions" id="apidoc.element.ender.local_package.prototype.extendOptions">
        function <span class="apidocSignatureSpan">ender.local_package.prototype.</span>extendOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extendOptions = function (options) {
  var externs = this.descriptor &amp;&amp; this.descriptor.externs
    , root = this.root

  if (externs) {
    if (!Array.isArray(externs)) externs = [ externs ]
    if (!options.externs) options.externs = []
    options.externs = options.externs.concat(externs.map(function (e) {
      return path.join(root, e)
    }))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (options.minifier == 'none') return callback(null, files)

    var minifier = minifiers[options.minifier || 'uglify']
      , extendedOptions = extend({}, options)

    if (!minifier) return new MinifyError('No such minifier: "' + options.minifier + '"')

    packages.forEach(function (pkg) { pkg.<span class="apidocCodeKeywordSpan">extendOptions</span>(extendedOptions) })
    minifier(files, filenames, extendedOptions, callback)
  }

, assembleBuild = function (callback) {
    assemble.assemble(filenames.build, filenames.sourceMap, options, packages, callback)
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package.prototype.loadDescriptor" id="apidoc.element.ender.local_package.prototype.loadDescriptor">
        function <span class="apidocSignatureSpan">ender.local_package.prototype.</span>loadDescriptor
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadDescriptor = function (callback) {
  var descriptorPath = repository.util.getPackageDescriptor(this.root)

  fs.readFile(descriptorPath, 'utf-8', function (err, data) {
    if (err) return callback(new FilesystemError(err))

    try {
      data = JSON.parse(data)
    } catch (err) {
      return callback(new JSONParseError(err.message + ' [' + descriptorPath + ']', err))
    }

    this.descriptor = LocalPackage.extendDescriptor(data)
    this.name = this.descriptor.name
    this.version = this.descriptor.version || ''
    this.description = this.descriptor.description || ''
    this.bare = !!this.descriptor.bare

    callback()
  }.bind(this))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  createPackage: function (root) {
    root = path.resolve(root)
    return packageCache[root] || (packageCache[root] = new LocalPackage(root))
  }

, loadPackage: function (root, callback) {
    var pkg = LocalPackage.createPackage(root)
    pkg.<span class="apidocCodeKeywordSpan">loadDescriptor</span>(function (err) {
      if (err) return callback(err)
      callback(null, pkg)
    })
  }

, unloadPackage: function (root) {
    LocalPackage.createPackage(root).unload()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package.prototype.loadSources" id="apidoc.element.ender.local_package.prototype.loadSources">
        function <span class="apidocSignatureSpan">ender.local_package.prototype.</span>loadSources
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadSources = function (callback) {
  var loadFile = async.memoize(function (file, callback) {
        file = path.normalize(file)
        fs.readFile(path.join(this.root, file), 'utf-8', function (err, content) {
          if (err) return callback(new FilesystemError(err))
          callback(null, { name: file.replace(/(\.js)?$/, ''), content: content })
        })
      }.bind(this))

    , expandGlob = async.memoize(function (file, callback) {
        // use glob.Glob because it's easier to stub for tests
        new glob.Glob(file, { cwd: this.root, root: this.root, nomount: true }, function (err, files) {
          if (err) return callback(new FilesystemError(err))
          callback(null, files)
        })
      }.bind(this))

    , expandDirectory = async.memoize(function (file, callback) {
        fs.stat(path.join(this.root, file), function (err, stats) {
          if (err) return callback(new FilesystemError(err))
          if (!stats.isDirectory()) return callback(null, [ file ])

          fs.readdir(path.join(this.root, file), function (err, names) {
            if (err) return callback(new FilesystemError(err))

            var files = names.map(function (name) { return path.join(file, name) })
            async.concat(files, expandDirectory, callback)
          })
        }.bind(this))
      }.bind(this))

    , contractDirectory = async.memoize(function (file, callback) {
        fs.stat(path.join(this.root, file), function (err, stats) {
          if (err) return callback(new FilesystemError(err))
          if (stats.isDirectory()) return callback(null, [])
          return callback(null, [ file ])
        }.bind(this))
      }.bind(this))

    , loadModule = function (name, callback) {
        var files = this.descriptor[name] || []
        if (typeof files == 'string') files = [ files ]
        if (!Array.isArray(files)) files = files['scripts'] || []

        if (name == 'main' &amp;&amp; !files.length) {
          // default to index as the main module
          files = [ 'index', 'index.js' ]
        } else {
          // add additional search paths
          files = files.concat(files.map(function (file) { return file + '.js' }),
                               files.map(function (file) { return path.join(file, 'index.js') }))
        }

        async.waterfall([
            function (callback)          { async.concat(files, expandGlob, callback) }
          , function (files, callback)   { async.concat(files, contractDirectory, callback) }
          , function (files, callback)   { async.map(files, loadFile, callback) }
          , function (sources, callback) {
              if (sources.length &gt; 1) {
                // If we have an array of files, combine them into one file
                sources = [{
                    name: name
                  , content: sources.map(function (s) { return s.content }).join('\n\n')
                }]
              }

              callback(null, sources)
            }
        ], callback)
      }.bind(this)

    , loadFiles = function (callback) {
        var files = this.descriptor.files || []
        if (typeof files == 'string') files = [ files ]
        if (!Array.isArray(files)) files = files['scripts'] || []

        async.waterfall([
            function (callback)        { async.concat(files, expandGlob, callback) }
          , function (files, callback) { async.concat(files, expandDirectory, callback) }
          , function (files, callback) { callback(null, files.filter(function (f) { return /\.js$/.test(f) }).sort()) }
          , function (files, callback) { async.map(files, loadFile, callback) }
        ], callback)
      }.bind(this)

  async.parallel(
    {
        main:   loadModule.bind(null, 'main')
      , bridge: loadModule.bind(null, 'bridge')
      , files:  loadFiles
    },
    function (err, results) {
      if (err) return callback(err)

      // concat the results and filter duplicates (this works on objects because loadFile is memoized)
      this.sources = [].concat(results.main, results.bridge, results.files)
      this.sources = this.sources.filter(f ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

  , assembleBuild = function (callback) {
      assemble.assemble(filenames.build, filenames.sourceMap, options, packages, callback)
    }

  , loadSources = function (callback) {
      async.each(packages, function (pkg, callback) { pkg.<span class="apidocCodeKeywordSpan">loadSources</span>(callback) }, callback
)
    }

async.waterfall([
    loadSources
  , assembleBuild
  , minifyBuild
  , writeFiles
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package.prototype.unload" id="apidoc.element.ender.local_package.prototype.unload">
        function <span class="apidocSignatureSpan">ender.local_package.prototype.</span>unload
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unload = function () {
  delete this.loadDescriptor.memo._
  delete this.loadSources.memo._
  delete this.descriptor
  delete this.sources
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    pkg.loadDescriptor(function (err) {
      if (err) return callback(err)
      callback(null, pkg)
    })
  }

, unloadPackage: function (root) {
    LocalPackage.createPackage(root).<span class="apidocCodeKeywordSpan">unload</span>()

    for (var key in packageMappings)
      if (packageMappings[key] == root)
        delete packageMappings[key]
  }

, addPackageMapping: function (id, root) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.refresh" id="apidoc.module.ender.refresh">module ender.refresh</a></h1>


    <h2>
        <a href="#apidoc.element.ender.refresh.exec" id="apidoc.element.ender.refresh.exec">
        function <span class="apidocSignatureSpan">ender.refresh.</span>exec
        <span class="apidocSignatureSpan">(options, log, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (options, log, callback) {
  var filename = util.getInputFilenameFromOptions(options)
; delete options.use // don't want --use showing up in the 'Build:' context string
  util.parseContext(filename, function (err, context) {
    if (err) return callback(err)

    // set --force-install but don't leave a trace in the 'Build:' context string
    context.options['_force-install'] = true
    build.exec(context.options, log, callback)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


#!/usr/bin/env node

var main = require('../lib/main')
  , log  = require('../lib/util').defaultLogger

main.<span class="apidocCodeKeywordSpan">exec</span>(process.argv, log, function (err) {
  process.exit(err ? 1 : 0)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.remove" id="apidoc.module.ender.remove">module ender.remove</a></h1>


    <h2>
        <a href="#apidoc.element.ender.remove.exec" id="apidoc.element.ender.remove.exec">
        function <span class="apidocSignatureSpan">ender.remove.</span>exec
        <span class="apidocSignatureSpan">(options, log, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (options, log, callback) {
  var filename = util.getInputFilenameFromOptions(options)
    , toRemove = options.packages
    , finish   = function (err) {
        repository.packup(err)
        callback(err)
      }

; delete options.use // don't want --use showing up in the 'Build:' context string
  options.packages = [] // reset the packages list so argsParser.extend() doesn't include them

  util.parseContext(filename, function (err, context) {
    if (err) return callback(err)

    // merge the commandline with the ender.js build command
    options          = argsParser.extend(context.options, options)
    options.packages = options.packages.filter(function (p) {
      return toRemove.indexOf(p) == -1 // do the remove!
    })

    async.series(
        [
            repository.setup // shouldn't need to do a packup because main-build will do it
          , repository.uninstall.bind(null, toRemove)
          , build.exec.bind(null, options, log) // hard work done by main-build
        ]
      , finish
    )
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


#!/usr/bin/env node

var main = require('../lib/main')
  , log  = require('../lib/util').defaultLogger

main.<span class="apidocCodeKeywordSpan">exec</span>(process.argv, log, function (err) {
  process.exit(err ? 1 : 0)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.search" id="apidoc.module.ender.search">module ender.search</a></h1>


    <h2>
        <a href="#apidoc.element.ender.search.exec" id="apidoc.element.ender.search.exec">
        function <span class="apidocSignatureSpan">ender.search.</span>exec
        <span class="apidocSignatureSpan">(options, log, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (options, log, callback) {
  var terms   = options.packages
    , max     = options.max || defaultMax
    , handler = handle.bind(null, terms, max, log, callback)

  if (arguments.length &lt; 3) {
    callback = log
    log = undefined
  }

  if (!log) return callback()

  log.info('Searching NPM registry...')

  repository.setup(function (err) {
    if (err) return callback(err) // wrapped in repository.js
    repository.search(terms, handler)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


#!/usr/bin/env node

var main = require('../lib/main')
  , log  = require('../lib/util').defaultLogger

main.<span class="apidocCodeKeywordSpan">exec</span>(process.argv, log, function (err) {
  process.exit(err ? 1 : 0)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.util" id="apidoc.module.ender.util">module ender.util</a></h1>


    <h2>
        <a href="#apidoc.element.ender.util.getCorePackages" id="apidoc.element.ender.util.getCorePackages">
        function <span class="apidocSignatureSpan">ender.util.</span>getCorePackages
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCorePackages = function (options) {
  var corePackages = []

  if (options['client-lib'] != 'none')
    corePackages.push(options['client-lib'] || defaultClientLib)

  if (options['module-lib'] != 'none')
    corePackages.push(options['module-lib'] || defaultModuleLib)

  return corePackages
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          , [ 'ender-core', 'ender-commonjs', 'apkg', 'pkg2', 'pkg3', '.&amp;#
x27;, '..' ]
        )
      }
  }

, 'getCorePackages': {
      'no args': function () {
        assert.equals(util.<span class="apidocCodeKeywordSpan">getCorePackages</span>({}), ['ender-core', 'ender-
commonjs'])
      }
  }

, 'parseContext': {
      'test simple old-skool parse': function (done) {
        var content = ''
              + '/*!\n'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.util.getInputFilenameFromOptions" id="apidoc.element.ender.util.getInputFilenameFromOptions">
        function <span class="apidocSignatureSpan">ender.util.</span>getInputFilenameFromOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getInputFilenameFromOptions = function (options) {
  return options.use ? options.use.replace(/(\.js)?$/, '.js') : 'ender.js'
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */

var argsParser   = require('../args-parser')
, util         = require('../util')
, build        = require('./build')

, exec = function (options, log, callback) {
    var filename = util.<span class="apidocCodeKeywordSpan">getInputFilenameFromOptions</span>(options)
  ; delete options.use // don't want --use showing up in the 'Build:' context string
    util.parseContext(filename, function (err, context) {
      if (!err) options = argsParser.extend(context.options, options)
      // merge commandline args with the build command in ender.js
      build.exec(options, log, callback)
    })
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.util.packageList" id="apidoc.element.ender.util.packageList">
        function <span class="apidocSignatureSpan">ender.util.</span>packageList
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">packageList = function (options) {
  var ids = options.packages &amp;&amp; options.packages.length ? options.packages : [ '.' ]
  return getCorePackages(options).concat(ids)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
], function (err, files) {
  if (err) return callback(err)
  callback(null, files, filenames)
})
    }

  , exec = function (options, log, callback) {
var ids = util.<span class="apidocCodeKeywordSpan">packageList</span>(options)
  , refresh = options['force-install'] || options['_force-install']

if (arguments.length &lt; 3) {
  callback = log
  log = undefined
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.util.parseContext" id="apidoc.element.ender.util.parseContext">
        function <span class="apidocSignatureSpan">ender.util.</span>parseContext
        <span class="apidocSignatureSpan">(file, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseContext = function (file, callback) {
  fs.open(file, 'r', function (err, fd) {
    if (err) return callback(new FilesystemError(err))

    var buffer = new Buffer(2048)
    fs.read(fd, buffer, 0, 2048, null, function (err, bytesRead, buffer) {
      if (err) return callback(new FilesystemError(err))

      fs.close(fd, function () {
        // err? who cares, we have our data, let's use it and run for the hills!
        var options
          , error
          , match = String(buffer).match(buildInfoRegex)

        if (!match) {
          error = 'Could not parse ender spec from "' + file + '" (not an Ender build file?)'
          return callback(new BuildParseError(error))
        }

        try {
          options = argsParser.parseClean(match[1].split(' '))
        } catch (ex) {
          error = 'Could not parse ender spec from "' + file + '"'
          return callback(new BuildParseError(error, ex))
        }

        callback(null, {
            options  : options
          , packages : match[2] &amp;&amp; match[2].split(' ')
        })
      })
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var argsParser   = require('../args-parser')
  , util         = require('../util')
  , build        = require('./build')

  , exec = function (options, log, callback) {
      var filename = util.getInputFilenameFromOptions(options)
    ; delete options.use // don't want --use showing up in the 'Build:' context string
      util.<span class="apidocCodeKeywordSpan">parseContext</span>(filename, function (err, context) {
        if (!err) options = argsParser.extend(context.options, options)
        // merge commandline args with the build command in ender.js
        build.exec(options, log, callback)
      })
    }

module.exports.exec = exec
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.util.toKb" id="apidoc.element.ender.util.toKb">
        function <span class="apidocSignatureSpan">ender.util.</span>toKb
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toKb = function (size) {
  size = Math.round(size / 1024 * 10) / 10
  return size + ' kB'
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    , function (raw, callback) {
        zlib.gzip(raw, function (err, gzipped) {
          if (err) return callback(new CompressionError(err))
          callback(null, raw, gzipped)
        })
      }
    , function (raw, gzipped, callback) {
        if (log) log.info('Success! Your compiled source is {cyan}' + util.<span class="apidocCodeKeywordSpan">toKb</span>(raw.length) + '{/cyan} minified' +
                          ' and {cyan}' + util.toKb(gzipped.length) + '{/cyan} gzipped' +
                          ' and is available at {green}' + outfile.green + '{/green}')

        callback()
      }
  ], callback)
}
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.version" id="apidoc.module.ender.version">module ender.version</a></h1>


    <h2>
        <a href="#apidoc.element.ender.version.exec" id="apidoc.element.ender.version.exec">
        function <span class="apidocSignatureSpan">ender.version.</span>exec
        <span class="apidocSignatureSpan">(options, log, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (options, log, callback) {
  var file = path.resolve(__dirname, '..', '..', 'package.json')

  if (arguments.length &lt; 3) {
    callback = log
    log = undefined
  }

  if (!log) return callback()

  fs.readFile(file, 'utf-8', function (err, data) {
    if (err) return callback(new FilesystemError(err))
    try {
      data = JSON.parse(data)
    } catch (err) {
      return callback(new JSONParseError(err.message + ' [' + file + ']', err))
    }

    log.info('Active version: v' + data.version)
    callback()
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


#!/usr/bin/env node

var main = require('../lib/main')
  , log  = require('../lib/util').defaultLogger

main.<span class="apidocCodeKeywordSpan">exec</span>(process.argv, log, function (err) {
  process.exit(err ? 1 : 0)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.vlq" id="apidoc.module.ender.vlq">module ender.vlq</a></h1>


    <h2>
        <a href="#apidoc.element.ender.vlq.decode" id="apidoc.element.ender.vlq.decode">
        function <span class="apidocSignatureSpan">ender.vlq.</span>decode
        <span class="apidocSignatureSpan">(vlqstr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function (vlqstr) {
  var result = 0
    , digit
    , continuation
    , i

  for (i = 0, continuation = 1; continuation &amp;&amp; i &lt; vlqstr.length; i++) {
    digit = b64toi[vlqstr[i]]
    continuation = digit &amp; VLQ_BASE    // Get the continuation bit
    digit &amp;= VLQ_MASK                  // Mask off the continuation bit
    result += digit &lt;&lt; (VLQ_BITS * i)  // Add the digit to the result
  }

  if (continuation &amp;&amp; i == vlqstr.length) return NaN
  return { value: fromVLQ(result), rest: vlqstr.slice(i) }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.vlq.encode" id="apidoc.element.ender.vlq.encode">
        function <span class="apidocSignatureSpan">ender.vlq.</span>encode
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode = function (val) {
  var result = ''
    , vlq = toVLQ(val)
    , digit

  do {
    digit = vlq &amp; VLQ_MASK      // Get the digit
    vlq &gt;&gt;&gt;= VLQ_BITS           // Shift off the digit
    if (vlq) digit |= VLQ_BASE  // Set the continuation bit
    result += itob64[digit]
  } while (vlq &gt; 0)

  return result
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (!line.length) return ''

    sourceIndex += sourceIndexDelta
    sourceLine += sourceLineDelta

    return (
      vlq.<span class="apidocCodeKeywordSpan">encode</span>(indent || 0) +                                     // Adjust for indent
      vlq.encode(sourceIndexDelta) +                                // Set the source index
      vlq.encode(sourceLineDelta) +                                 // Set the source line
      vlq.encode(0) +                                               // Source column (always 0)
      (ending ? ';' : '')                                           // Did we have a line ending?
    )
  })
}
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>