<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://enderjs.com"

    >ender (v2.1.1)</a>
</h1>
<h4>Open Module JavaScript Framework</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender">module ender</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.exec">
            function <span class="apidocSignatureSpan">ender.</span>exec
            <span class="apidocSignatureSpan">(argv, log, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package">
            function <span class="apidocSignatureSpan">ender.</span>local_package
            <span class="apidocSignatureSpan">(root)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>add</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>args_parser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>assemble</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>compile</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>errors</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>help</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>index</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>info</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>local_package.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>refresh</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>remove</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>search</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>version</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.</span>vlq</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.add">module ender.add</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.add.exec">
            function <span class="apidocSignatureSpan">ender.add.</span>exec
            <span class="apidocSignatureSpan">(options, log, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.args_parser">module ender.args_parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.args_parser.extend">
            function <span class="apidocSignatureSpan">ender.args_parser.</span>extend
            <span class="apidocSignatureSpan">(originalArgs, newArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.args_parser.parse">
            function <span class="apidocSignatureSpan">ender.args_parser.</span>parse
            <span class="apidocSignatureSpan">(argv)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.args_parser.parseClean">
            function <span class="apidocSignatureSpan">ender.args_parser.</span>parseClean
            <span class="apidocSignatureSpan">(argv)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.args_parser.toContextString">
            function <span class="apidocSignatureSpan">ender.args_parser.</span>toContextString
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.assemble">module ender.assemble</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.assemble.assemble">
            function <span class="apidocSignatureSpan">ender.</span>assemble
            <span class="apidocSignatureSpan">(buildName, sourceMapName, options, packages, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.compile">module ender.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.compile.exec">
            function <span class="apidocSignatureSpan">ender.compile.</span>exec
            <span class="apidocSignatureSpan">(options, log, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.errors">module ender.errors</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.ArgumentParserError">
            function <span class="apidocSignatureSpan">ender.errors.</span>ArgumentParserError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.BuildError">
            function <span class="apidocSignatureSpan">ender.errors.</span>BuildError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.BuildParseError">
            function <span class="apidocSignatureSpan">ender.errors.</span>BuildParseError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.ChildProcessError">
            function <span class="apidocSignatureSpan">ender.errors.</span>ChildProcessError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.CommandError">
            function <span class="apidocSignatureSpan">ender.errors.</span>CommandError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.CompressionError">
            function <span class="apidocSignatureSpan">ender.errors.</span>CompressionError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.DependencyLoopError">
            function <span class="apidocSignatureSpan">ender.errors.</span>DependencyLoopError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.EnderError">
            function <span class="apidocSignatureSpan">ender.errors.</span>EnderError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.FilesystemError">
            function <span class="apidocSignatureSpan">ender.errors.</span>FilesystemError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.InstallError">
            function <span class="apidocSignatureSpan">ender.errors.</span>InstallError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.JSONParseError">
            function <span class="apidocSignatureSpan">ender.errors.</span>JSONParseError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.MinifyError">
            function <span class="apidocSignatureSpan">ender.errors.</span>MinifyError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.PackageError">
            function <span class="apidocSignatureSpan">ender.errors.</span>PackageError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.PackageNotFoundError">
            function <span class="apidocSignatureSpan">ender.errors.</span>PackageNotFoundError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.PackageNotLocalError">
            function <span class="apidocSignatureSpan">ender.errors.</span>PackageNotLocalError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.RepositoryCommandError">
            function <span class="apidocSignatureSpan">ender.errors.</span>RepositoryCommandError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.RepositoryError">
            function <span class="apidocSignatureSpan">ender.errors.</span>RepositoryError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.RepositorySetupError">
            function <span class="apidocSignatureSpan">ender.errors.</span>RepositorySetupError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.TemplateError">
            function <span class="apidocSignatureSpan">ender.errors.</span>TemplateError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.UnknownCommandError">
            function <span class="apidocSignatureSpan">ender.errors.</span>UnknownCommandError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.errors.UnknownOptionError">
            function <span class="apidocSignatureSpan">ender.errors.</span>UnknownOptionError
            <span class="apidocSignatureSpan">(message, cause)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.help">module ender.help</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.help.exec">
            function <span class="apidocSignatureSpan">ender.help.</span>exec
            <span class="apidocSignatureSpan">(options, log, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.index">module ender.index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.index.closure">
            function <span class="apidocSignatureSpan">ender.index.</span>closure
            <span class="apidocSignatureSpan">(files, filenames, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.index.uglify">
            function <span class="apidocSignatureSpan">ender.index.</span>uglify
            <span class="apidocSignatureSpan">(files, filenames, options, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.info">module ender.info</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.info.exec">
            function <span class="apidocSignatureSpan">ender.info.</span>exec
            <span class="apidocSignatureSpan">(options, log, callback, buildName, ids, files)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.local_package">module ender.local_package</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.local_package">
            function <span class="apidocSignatureSpan">ender.</span>local_package
            <span class="apidocSignatureSpan">(root)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.addPackageMapping">
            function <span class="apidocSignatureSpan">ender.local_package.</span>addPackageMapping
            <span class="apidocSignatureSpan">(id, root)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.buildTree">
            function <span class="apidocSignatureSpan">ender.local_package.</span>buildTree
            <span class="apidocSignatureSpan">(ids, pretty, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.createPackage">
            function <span class="apidocSignatureSpan">ender.local_package.</span>createPackage
            <span class="apidocSignatureSpan">(root)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.extendDescriptor">
            function <span class="apidocSignatureSpan">ender.local_package.</span>extendDescriptor
            <span class="apidocSignatureSpan">(descriptor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.findPackage">
            function <span class="apidocSignatureSpan">ender.local_package.</span>findPackage
            <span class="apidocSignatureSpan">(id, root, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.loadPackage">
            function <span class="apidocSignatureSpan">ender.local_package.</span>loadPackage
            <span class="apidocSignatureSpan">(root, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.unloadPackage">
            function <span class="apidocSignatureSpan">ender.local_package.</span>unloadPackage
            <span class="apidocSignatureSpan">(root)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.walkDependencies">
            function <span class="apidocSignatureSpan">ender.local_package.</span>walkDependencies
            <span class="apidocSignatureSpan">(ids, unique, strict, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.local_package.prototype">module ender.local_package.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.prototype.extendOptions">
            function <span class="apidocSignatureSpan">ender.local_package.prototype.</span>extendOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.prototype.loadDescriptor">
            function <span class="apidocSignatureSpan">ender.local_package.prototype.</span>loadDescriptor
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.prototype.loadSources">
            function <span class="apidocSignatureSpan">ender.local_package.prototype.</span>loadSources
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.local_package.prototype.unload">
            function <span class="apidocSignatureSpan">ender.local_package.prototype.</span>unload
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.refresh">module ender.refresh</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.refresh.exec">
            function <span class="apidocSignatureSpan">ender.refresh.</span>exec
            <span class="apidocSignatureSpan">(options, log, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.remove">module ender.remove</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.remove.exec">
            function <span class="apidocSignatureSpan">ender.remove.</span>exec
            <span class="apidocSignatureSpan">(options, log, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.search">module ender.search</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.search.exec">
            function <span class="apidocSignatureSpan">ender.search.</span>exec
            <span class="apidocSignatureSpan">(options, log, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.util">module ender.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.util.getCorePackages">
            function <span class="apidocSignatureSpan">ender.util.</span>getCorePackages
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.util.getInputFilenameFromOptions">
            function <span class="apidocSignatureSpan">ender.util.</span>getInputFilenameFromOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.util.packageList">
            function <span class="apidocSignatureSpan">ender.util.</span>packageList
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.util.parseContext">
            function <span class="apidocSignatureSpan">ender.util.</span>parseContext
            <span class="apidocSignatureSpan">(file, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.util.toKb">
            function <span class="apidocSignatureSpan">ender.util.</span>toKb
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ender.util.</span>defaultLogger</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.version">module ender.version</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.version.exec">
            function <span class="apidocSignatureSpan">ender.version.</span>exec
            <span class="apidocSignatureSpan">(options, log, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ender.vlq">module ender.vlq</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.vlq.decode">
            function <span class="apidocSignatureSpan">ender.vlq.</span>decode
            <span class="apidocSignatureSpan">(vlqstr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ender.vlq.encode">
            function <span class="apidocSignatureSpan">ender.vlq.</span>encode
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender" id="apidoc.module.ender">module ender</a></h1>


    <h2>
        <a href="#apidoc.element.ender.exec" id="apidoc.element.ender.exec">
        function <span class="apidocSignatureSpan">ender.</span>exec
        <span class="apidocSignatureSpan">(argv, log, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (argv, log, callback) {
  var parseType = &#x27;parse&#x27;
    , options

    , complete = function (err) {
        if (err &#x26;&#x26; log) {
          var name = (err.name || &#x27;Error&#x27;).replace(/([a-z])([A-Z])/g, &#x27;$1 $2&#x27;)

          log.error(&#x27;{red}{bold}&#x27; + name + &#x27;: {/bold}&#x27; + err.message + &#x27;{/red}&#x27;)

          if (options.debug) {
            log.error(err.stack)
            if (err.cause) log.error(&#x27;Caused by:\n&#x27; + err.cause.stack)

          } else log.error(&#x27;Run with --debug to see more information&#x27;)
        }

        callback(err)
      }

  if (arguments.length &#x3c; 3) {
    callback = log
    log = undefined
  }

  if (typeof argv == &#x27;string&#x27;) {
    // for API use: ender.exec(&#x27;ender &#x3c;cmd&#x3e;&#x27;, cb)
    argv = argv.split(/\s/).slice(1)
    parseType = &#x27;parseClean&#x27; // parseClean knows there aren&#x27;t 2 preceeding tokens
  }

  try {
    options = argsParser[parseType](argv)
    require(&#x27;./commands/&#x27; + options.command).exec(options, log, complete)
  } catch (ex) {
    options = options || { debug: argv.indexOf(&#x27;--debug&#x27;) != -1 }
    complete(ex)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


#!/usr/bin/env node

var main = require(&#x27;../lib/main&#x27;)
  , log  = require(&#x27;../lib/util&#x27;).defaultLogger

main.<span class="apidocCodeKeywordSpan">exec</span>(process.argv, log, function (err) {
  process.exit(err ? 1 : 0)
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package" id="apidoc.element.ender.local_package">
        function <span class="apidocSignatureSpan">ender.</span>local_package
        <span class="apidocSignatureSpan">(root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LocalPackage(root) {
  this.root = root

  // Memoize methods that hit the disk
  this.loadDescriptor = async.memoize(this.loadDescriptor.bind(this), unitaryHash)
  this.loadSources = async.memoize(this.loadSources.bind(this), unitaryHash)

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.add" id="apidoc.module.ender.add">module ender.add</a></h1>


    <h2>
        <a href="#apidoc.element.ender.add.exec" id="apidoc.element.ender.add.exec">
        function <span class="apidocSignatureSpan">ender.add.</span>exec
        <span class="apidocSignatureSpan">(options, log, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (options, log, callback) {
  var filename = util.getInputFilenameFromOptions(options)
; delete options.use // don&#x27;t want --use showing up in the &#x27;Build:&#x27; context string
  util.parseContext(filename, function (err, context) {
    if (!err) options = argsParser.extend(context.options, options)
    // merge commandline args with the build command in ender.js
    build.exec(options, log, callback)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


#!/usr/bin/env node

var main = require(&#x27;../lib/main&#x27;)
  , log  = require(&#x27;../lib/util&#x27;).defaultLogger

main.<span class="apidocCodeKeywordSpan">exec</span>(process.argv, log, function (err) {
  process.exit(err ? 1 : 0)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.args_parser" id="apidoc.module.ender.args_parser">module ender.args_parser</a></h1>


    <h2>
        <a href="#apidoc.element.ender.args_parser.extend" id="apidoc.element.ender.args_parser.extend">
        function <span class="apidocSignatureSpan">ender.args_parser.</span>extend
        <span class="apidocSignatureSpan">(originalArgs, newArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (originalArgs, newArgs) {
  return parse(toContextString(newArgs).split(&#x27; &#x27;), 1, originalArgs)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  , util         = require(&#x27;../util&#x27;)
  , build        = require(&#x27;./build&#x27;)

  , exec = function (options, log, callback) {
      var filename = util.getInputFilenameFromOptions(options)
    ; delete options.use // don&#x27;t want --use showing up in the &#x27;Build:&#x27; context string
      util.parseContext(filename, function (err, context) {
        if (!err) options = argsParser.<span class="apidocCodeKeywordSpan">extend</span>(context.options, options)
        // merge commandline args with the build command in ender.js
        build.exec(options, log, callback)
      })
    }

module.exports.exec = exec
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.args_parser.parse" id="apidoc.element.ender.args_parser.parse">
        function <span class="apidocSignatureSpan">ender.args_parser.</span>parse
        <span class="apidocSignatureSpan">(argv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (argv) { return parse(argv, 2) }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  , loadDescriptor: function (callback) {
      var descriptorPath = repository.util.getPackageDescriptor(this.root)

      fs.readFile(descriptorPath, &#x27;utf-8&#x27;, function (err, data) {
if (err) return callback(new FilesystemError(err))

try {
  data = JSON.<span class="apidocCodeKeywordSpan">parse</span>(data)
} catch (err) {
  return callback(new JSONParseError(err.message + &#x27; [&#x27; + descriptorPath + &#x27;]&#x27;, err))
}

this.descriptor = LocalPackage.extendDescriptor(data)
this.name = this.descriptor.name
this.version = this.descriptor.version || &#x27;&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.args_parser.parseClean" id="apidoc.element.ender.args_parser.parseClean">
        function <span class="apidocSignatureSpan">ender.args_parser.</span>parseClean
        <span class="apidocSignatureSpan">(argv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseClean = function (argv) { return parse(argv, 0) }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (!match) {
  error = &#x27;Could not parse ender spec from &#x22;&#x27; + file + &#x27;&#x22; (not an Ender build file?)&#x27;
  return callback(new BuildParseError(error))
}

try {
  options = argsParser.<span class="apidocCodeKeywordSpan">parseClean</span>(match[1].split(&#x27; &#x27;))
} catch (ex) {
  error = &#x27;Could not parse ender spec from &#x22;&#x27; + file + &#x27;&#x22;&#x27;
  return callback(new BuildParseError(error, ex))
}

callback(null, {
    options  : options
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.args_parser.toContextString" id="apidoc.element.ender.args_parser.toContextString">
        function <span class="apidocSignatureSpan">ender.args_parser.</span>toContextString
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toContextString = function (options) {
  var str = options.command
    , p

  if (options.packages.length) str += &#x27; &#x27; + options.packages.join(&#x27; &#x27;)

  for (p in options) {
    if (p === &#x27;packages&#x27; || p === &#x27;command&#x27;) continue
    str += &#x27; --&#x27; + p
    if (Array.isArray(options[p])) str += &#x27; &#x27; + options[p].join(&#x27; &#x27;)
    else if (typeof options[p] !== &#x27;boolean&#x27;) str += &#x27; &#x27; + options[p]
  }
  return str
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return str &#x26;&#x26; str.replace(/^/mg, Array(spaces+1).join(&#x27; &#x27;))
    }

  , assemble = function (buildName, sourceMapName, options, packages, callback) {
      var templateData = {
      buildName: buildName
    , sourceMapName: sourceMapName
    , context: argsParser.<span class="apidocCodeKeywordSpan">toContextString</span>(options)
    , packageList: []
    , packages: []
  }

, sourceIndex = 0
, sourceLine = 0
, sourceNames = []
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.assemble" id="apidoc.module.ender.assemble">module ender.assemble</a></h1>


    <h2>
        <a href="#apidoc.element.ender.assemble.assemble" id="apidoc.element.ender.assemble.assemble">
        function <span class="apidocSignatureSpan">ender.</span>assemble
        <span class="apidocSignatureSpan">(buildName, sourceMapName, options, packages, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assemble = function (buildName, sourceMapName, options, packages, callback) {
  var templateData = {
          buildName: buildName
        , sourceMapName: sourceMapName
        , context: argsParser.toContextString(options)
        , packageList: []
        , packages: []
      }

    , sourceIndex = 0
    , sourceLine = 0
    , sourceNames = []
    , generateMappings = function (name, content, indent, inline) {
        if (sourceNames.indexOf(name) == -1) sourceNames.push(name)

        return content.replace(/^.*$(\r\n|\r|\n)?/mg, function (line, ending, offset) {
          var firstLine = !offset
            , sourceIndexDelta = (firstLine ? sourceNames.indexOf(name) - sourceIndex : 0)
            , sourceLineDelta = (firstLine ? -sourceLine : 1)

          if (!line.length) return &#x27;&#x27;

          sourceIndex += sourceIndexDelta
          sourceLine += sourceLineDelta

          return (
            vlq.encode(indent || 0) +                                     // Adjust for indent
            vlq.encode(sourceIndexDelta) +                                // Set the source index
            vlq.encode(sourceLineDelta) +                                 // Set the source line
            vlq.encode(0) +                                               // Source column (always 0)
            (ending ? &#x27;;&#x27; : &#x27;&#x27;)                                           // Did we have a line ending?
          )
        })
      }

  packages.forEach(function (pkg) {
    templateData.packageList.push(pkg.id)

    // are we autointegrating this package?
    if (!pkg.bridge &#x26;&#x26; Array.isArray(options.integrate) &#x26;&#x26; options.integrate.indexOf(pkg.name) != -1) {
      pkg.sources.push({ name: &#x27;bridge&#x27;, content: generateDefaultBridge(pkg.name) })
      pkg.bridge = &#x27;bridge&#x27;
    }

    if (pkg.sources.length) {
      var pkgData = {
              isBare: pkg.bare
            , isExposed: pkg.bare

            , name: pkg.name
            , main: pkg.main
            , bridge: pkg.bridge
            , sources: []
          }

        , relativeRoot = path.relative(&#x27;.&#x27;, pkg.root)

      // do we have a sandboxed build?
      if (Array.isArray(options.sandbox)) {
        pkgData.isExposed = (options.sandbox.indexOf(pkg.name) != -1)
      }

      pkg.sources.forEach(function (source, i) {
        var indent = pkg.bare ? 2 : 6
          , indentedContent = indentLines(source.content, indent)

        // check if this is the bridge and we want to exclude it from the build
        if (pkg.bare &#x26;&#x26; !pkgData.isExposed &#x26;&#x26; source.name == pkg.bridge) {
          delete pkgData.bridge
          return
        }

        pkgData.sources.push({
            i: i
          , name: source.name
          , content: indentedContent
          , mappings: generateMappings(path.join(relativeRoot, source.name + &#x27;.js&#x27;), source.content, indent)
        })
      })

      templateData.packages.push(pkgData)
    }
  })

  templateData.packageList = templateData.packageList.join(&#x27; &#x27;)
  templateData.sourceList = JSON.stringify(sourceNames)

  async.parallel({
      build: function (callback) {
        var source = &#x27;&#x27;
        mu.compileAndRender(&#x27;build.mustache&#x27;, templateData)
          .on(&#x27;error&#x27;, function (err) { callback(new TemplateError(err)) })
          .on(&#x27;data&#x27;, function (data) { source += data })
          .on(&#x27;end&#x27;, function () { callback(null, source) })
      }

    , sourceMap: function (callback) {
        var sourceMap = &#x27;&#x27;
        mu.compileAndRender(&#x27;build.map.mustache&#x27;, templateData)
          .on(&#x27;error&#x27;, function (err) { callback(new TemplateError(err)) })
          .on(&#x27;data&#x27;, function (data) { sourceMap += data })
          .on(&#x27;end&#x27;, function () { callback(null, sourceMap) })
      }
  }, callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (!minifier) return new MinifyError(&#x27;No such minifier: &#x22;&#x27; + options.minifier + &#x27;&#x22;&#x27;)

      packages.forEach(function (pkg) { pkg.extendOptions(extendedOptions) })
      minifier(files, filenames, extendedOptions, callback)
    }

  , assembleBuild = function (callback) {
      assemble.<span class="apidocCodeKeywordSpan">assemble</span>(filenames.build, filenames.sourceMap, options, packages, callback
)
    }

  , loadSources = function (callback) {
      async.each(packages, function (pkg, callback) { pkg.loadSources(callback) }, callback)
    }

async.waterfall([
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.compile" id="apidoc.module.ender.compile">module ender.compile</a></h1>


    <h2>
        <a href="#apidoc.element.ender.compile.exec" id="apidoc.element.ender.compile.exec">
        function <span class="apidocSignatureSpan">ender.compile.</span>exec
        <span class="apidocSignatureSpan">(options, log, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (options, log, callback) {
  var outfile

  if (arguments.length &#x3c; 3) {
    callback = log
    log = undefined
  }

  if (log) log.info(&#x27;Running Closure Compiler...&#x27;)

  async.waterfall([
      function (callback) {
        closure(options, function (err, file) {
          if (err) return callback(err) // wrapped in closure()
          callback(null, outfile = file)
        })
      }
    , function (file, callback) {
        fs.readFile(file, &#x27;utf-8&#x27;, function (err, data) {
          if (err) return callback(new FilesystemError(err))
          callback(null, data)
        })
      }
    , function (raw, callback) {
        zlib.gzip(raw, function (err, gzipped) {
          if (err) return callback(new CompressionError(err))
          callback(null, raw, gzipped)
        })
      }
    , function (raw, gzipped, callback) {
        if (log) log.info(&#x27;Success! Your compiled source is {cyan}&#x27; + util.toKb(raw.length) + &#x27;{/cyan} minified&#x27; +
                          &#x27; and {cyan}&#x27; + util.toKb(gzipped.length) + &#x27;{/cyan} gzipped&#x27; +
                          &#x27; and is available at {green}&#x27; + outfile.green + &#x27;{/green}&#x27;)

        callback()
      }
  ], callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


#!/usr/bin/env node

var main = require(&#x27;../lib/main&#x27;)
  , log  = require(&#x27;../lib/util&#x27;).defaultLogger

main.<span class="apidocCodeKeywordSpan">exec</span>(process.argv, log, function (err) {
  process.exit(err ? 1 : 0)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.errors" id="apidoc.module.ender.errors">module ender.errors</a></h1>


    <h2>
        <a href="#apidoc.element.ender.errors.ArgumentParserError" id="apidoc.element.ender.errors.ArgumentParserError">
        function <span class="apidocSignatureSpan">ender.errors.</span>ArgumentParserError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ArgumentParserError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == &#x27;FilesystemError&#x27;) {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? &#x27; [&#x27; + this.cause.path + &#x27;]&#x27; : &#x27;&#x27;)
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.BuildError" id="apidoc.element.ender.errors.BuildError">
        function <span class="apidocSignatureSpan">ender.errors.</span>BuildError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BuildError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == &#x27;FilesystemError&#x27;) {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? &#x27; [&#x27; + this.cause.path + &#x27;]&#x27; : &#x27;&#x27;)
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.BuildParseError" id="apidoc.element.ender.errors.BuildParseError">
        function <span class="apidocSignatureSpan">ender.errors.</span>BuildParseError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BuildParseError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == &#x27;FilesystemError&#x27;) {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? &#x27; [&#x27; + this.cause.path + &#x27;]&#x27; : &#x27;&#x27;)
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.ChildProcessError" id="apidoc.element.ender.errors.ChildProcessError">
        function <span class="apidocSignatureSpan">ender.errors.</span>ChildProcessError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ChildProcessError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == &#x27;FilesystemError&#x27;) {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? &#x27; [&#x27; + this.cause.path + &#x27;]&#x27; : &#x27;&#x27;)
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.CommandError" id="apidoc.element.ender.errors.CommandError">
        function <span class="apidocSignatureSpan">ender.errors.</span>CommandError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CommandError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == &#x27;FilesystemError&#x27;) {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? &#x27; [&#x27; + this.cause.path + &#x27;]&#x27; : &#x27;&#x27;)
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.CompressionError" id="apidoc.element.ender.errors.CompressionError">
        function <span class="apidocSignatureSpan">ender.errors.</span>CompressionError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">CompressionError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == &#x27;FilesystemError&#x27;) {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? &#x27; [&#x27; + this.cause.path + &#x27;]&#x27; : &#x27;&#x27;)
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.DependencyLoopError" id="apidoc.element.ender.errors.DependencyLoopError">
        function <span class="apidocSignatureSpan">ender.errors.</span>DependencyLoopError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DependencyLoopError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == &#x27;FilesystemError&#x27;) {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? &#x27; [&#x27; + this.cause.path + &#x27;]&#x27; : &#x27;&#x27;)
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.EnderError" id="apidoc.element.ender.errors.EnderError">
        function <span class="apidocSignatureSpan">ender.errors.</span>EnderError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">EnderError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == &#x27;FilesystemError&#x27;) {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? &#x27; [&#x27; + this.cause.path + &#x27;]&#x27; : &#x27;&#x27;)
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.FilesystemError" id="apidoc.element.ender.errors.FilesystemError">
        function <span class="apidocSignatureSpan">ender.errors.</span>FilesystemError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FilesystemError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == &#x27;FilesystemError&#x27;) {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? &#x27; [&#x27; + this.cause.path + &#x27;]&#x27; : &#x27;&#x27;)
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.InstallError" id="apidoc.element.ender.errors.InstallError">
        function <span class="apidocSignatureSpan">ender.errors.</span>InstallError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">InstallError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == &#x27;FilesystemError&#x27;) {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? &#x27; [&#x27; + this.cause.path + &#x27;]&#x27; : &#x27;&#x27;)
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.JSONParseError" id="apidoc.element.ender.errors.JSONParseError">
        function <span class="apidocSignatureSpan">ender.errors.</span>JSONParseError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JSONParseError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == &#x27;FilesystemError&#x27;) {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? &#x27; [&#x27; + this.cause.path + &#x27;]&#x27; : &#x27;&#x27;)
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.MinifyError" id="apidoc.element.ender.errors.MinifyError">
        function <span class="apidocSignatureSpan">ender.errors.</span>MinifyError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MinifyError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == &#x27;FilesystemError&#x27;) {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? &#x27; [&#x27; + this.cause.path + &#x27;]&#x27; : &#x27;&#x27;)
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.PackageError" id="apidoc.element.ender.errors.PackageError">
        function <span class="apidocSignatureSpan">ender.errors.</span>PackageError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PackageError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == &#x27;FilesystemError&#x27;) {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? &#x27; [&#x27; + this.cause.path + &#x27;]&#x27; : &#x27;&#x27;)
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.PackageNotFoundError" id="apidoc.element.ender.errors.PackageNotFoundError">
        function <span class="apidocSignatureSpan">ender.errors.</span>PackageNotFoundError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PackageNotFoundError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == &#x27;FilesystemError&#x27;) {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? &#x27; [&#x27; + this.cause.path + &#x27;]&#x27; : &#x27;&#x27;)
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.PackageNotLocalError" id="apidoc.element.ender.errors.PackageNotLocalError">
        function <span class="apidocSignatureSpan">ender.errors.</span>PackageNotLocalError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PackageNotLocalError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == &#x27;FilesystemError&#x27;) {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? &#x27; [&#x27; + this.cause.path + &#x27;]&#x27; : &#x27;&#x27;)
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.RepositoryCommandError" id="apidoc.element.ender.errors.RepositoryCommandError">
        function <span class="apidocSignatureSpan">ender.errors.</span>RepositoryCommandError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RepositoryCommandError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == &#x27;FilesystemError&#x27;) {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? &#x27; [&#x27; + this.cause.path + &#x27;]&#x27; : &#x27;&#x27;)
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.RepositoryError" id="apidoc.element.ender.errors.RepositoryError">
        function <span class="apidocSignatureSpan">ender.errors.</span>RepositoryError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RepositoryError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == &#x27;FilesystemError&#x27;) {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? &#x27; [&#x27; + this.cause.path + &#x27;]&#x27; : &#x27;&#x27;)
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.RepositorySetupError" id="apidoc.element.ender.errors.RepositorySetupError">
        function <span class="apidocSignatureSpan">ender.errors.</span>RepositorySetupError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RepositorySetupError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == &#x27;FilesystemError&#x27;) {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? &#x27; [&#x27; + this.cause.path + &#x27;]&#x27; : &#x27;&#x27;)
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.TemplateError" id="apidoc.element.ender.errors.TemplateError">
        function <span class="apidocSignatureSpan">ender.errors.</span>TemplateError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TemplateError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == &#x27;FilesystemError&#x27;) {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? &#x27; [&#x27; + this.cause.path + &#x27;]&#x27; : &#x27;&#x27;)
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.UnknownCommandError" id="apidoc.element.ender.errors.UnknownCommandError">
        function <span class="apidocSignatureSpan">ender.errors.</span>UnknownCommandError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">UnknownCommandError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == &#x27;FilesystemError&#x27;) {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? &#x27; [&#x27; + this.cause.path + &#x27;]&#x27; : &#x27;&#x27;)
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.errors.UnknownOptionError" id="apidoc.element.ender.errors.UnknownOptionError">
        function <span class="apidocSignatureSpan">ender.errors.</span>UnknownOptionError
        <span class="apidocSignatureSpan">(message, cause)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">UnknownOptionError = function (message, cause) {
  init.call(this, name, message, cause)
  //TODO: the specificity here is stupid, errno should be available everywhere
  if (name == &#x27;FilesystemError&#x27;) {
    this.code    = this.cause.code
    this.path    = this.cause.path
    this.errno   = this.cause.errno
    this.message =
      (errno.errno[this.cause.errno]
        ? errno.errno[this.cause.errno].description
        : this.cause.message)
      + (this.cause.path ? &#x27; [&#x27; + this.cause.path + &#x27;]&#x27; : &#x27;&#x27;)
  }
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, arguments.callee)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.help" id="apidoc.module.ender.help">module ender.help</a></h1>


    <h2>
        <a href="#apidoc.element.ender.help.exec" id="apidoc.element.ender.help.exec">
        function <span class="apidocSignatureSpan">ender.help.</span>exec
        <span class="apidocSignatureSpan">(options, log, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (options, log, callback) {
  var page = options.packages[0] || &#x27;main&#x27;
    , file

  if (arguments.length &#x3c; 3) {
    callback = log
    log = undefined
  }

  if (!log) return callback()

  page = page.toLowerCase().replace(/[^a-z]/g,&#x27;&#x27;)
  page = aliases[page] || page
  file = path.join(templateDirectory, page + &#x27;.tmpl&#x27;)

  fs.exists(file, function (exists) {
    if (exists) {
      fs.readFile(file, &#x27;utf-8&#x27;, function (err, template) {
        if (err) return callback(new FilesystemError(err))
        log.info(template)
        callback()
      })
    } else {
      log.warn(&#x27;No such command: {yellow}&#x27; + page + &#x27;{/yellow}\n&#x27; +
               &#x27;Use {cyan}ender help{/cyan} to show a summary of basic commands&#x27;)

      callback()
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


#!/usr/bin/env node

var main = require(&#x27;../lib/main&#x27;)
  , log  = require(&#x27;../lib/util&#x27;).defaultLogger

main.<span class="apidocCodeKeywordSpan">exec</span>(process.argv, log, function (err) {
  process.exit(err ? 1 : 0)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.index" id="apidoc.module.ender.index">module ender.index</a></h1>


    <h2>
        <a href="#apidoc.element.ender.index.closure" id="apidoc.element.ender.index.closure">
        function <span class="apidocSignatureSpan">ender.index.</span>closure
        <span class="apidocSignatureSpan">(files, filenames, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closure = function (files, filenames, options, callback) {
  var comments  = []
    , stdin     = files.build.replace(reMultiComments, function(full, comment) {
                    comments.push(comment)
                    return &#x27;/** @preserve &#x27; + token + &#x27;*/&#x27;
                  })
    , stdout    = &#x27;&#x27;
    , stderr    = &#x27;&#x27;
    , javaArgs  = [&#x27;-jar&#x27;, jarPath]
    , child

  if (levels.hasOwnProperty(options.level))
    javaArgs.push(&#x27;--compilation_level=&#x27; + levels[options.level])

  if (filenames.minifiedSourceMap)
    javaArgs.push(&#x27;--create_source_map=&#x27; + filenames.minifiedSourceMap)

  if (options.externs)
    javaArgs.concat(options.externs.map(function (e) { return &#x27;--externs=&#x27; + e }))

  child = childProcess.spawn(javaCmd, javaArgs)

  child.stdout.on(&#x27;data&#x27;, function (data) {
    stdout += data.toString(&#x27;utf-8&#x27;)
  })

  child.stderr.on(&#x27;data&#x27;, function (data) {
    stderr += data.toString(&#x27;utf-8&#x27;)
  })

  child.on(&#x27;exit&#x27;, function (code, signal) {
    var err
    if (code !== 0) {
      err = new MinifyError(&#x27;Child process exited on signal: &#x27; + signal)
      err.stderr = stderr
      return callback(err)
    }
    stdout = stdout.replace(reTokens, function() {
      return &#x27;\n&#x27; + comments.shift().replace(/(^[\n\s]+)|([\n\s]+$)/g, &#x27;&#x27;)
    })

    files.minifiedBuild = stdout
    callback(null, files)
  })

  child.stdin.write(stdin, &#x27;utf-8&#x27;)
  child.stdin.end()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.index.uglify" id="apidoc.element.ender.index.uglify">
        function <span class="apidocSignatureSpan">ender.index.</span>uglify
        <span class="apidocSignatureSpan">(files, filenames, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uglify = function (files, filenames, options, callback) {
    try {
      var ast = UglifyJS.parse(files.build, { filename: filenames.build })
        , sourceMap = UglifyJS.SourceMap({ file: filenames.minifiedBuild, orig: files.sourceMap })
        , compressor = UglifyJS.Compressor()
        , minifiedBuild

      // Supress warnings (mainly to prevent extraneous SourceMap warnings)
      UglifyJS.AST_Node.warn_function = null

      ast.figure_out_scope()
      ast = ast.transform(compressor)
      ast.figure_out_scope()
      ast.compute_char_frequency()
      ast.mangle_names()

      files.minifiedBuild = ast.print_to_string({
          source_map: sourceMap
        , comments: function (node, comment) {
            return comment.type == &#x22;comment2&#x22; &#x26;&#x26; /^!|@preserve|@license|@cc_on/i.test(comment.value)
          }
      })

      files.minifiedSourceMap = sourceMap.toString()
      callback(null, files)

    } catch (ex) {
      var err = new MinifyError(&#x27;Uglify error&#x27;)
      err.cause = ex
      return callback(err)
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.info" id="apidoc.module.ender.info">module ender.info</a></h1>


    <h2>
        <a href="#apidoc.element.ender.info.exec" id="apidoc.element.ender.info.exec">
        function <span class="apidocSignatureSpan">ender.info.</span>exec
        <span class="apidocSignatureSpan">(options, log, callback, buildName, ids, files)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (options, log, callback, buildName, ids, files) {
  var sizes = {}

    , finish = function (callback) {

        log.info(&#x27;Your current build command is: {yellow}ender &#x27; + argsParser.toContextString(options) + &#x27;{/yellow}&#x27;)
        log.info(
          &#x27;Your current build size is: {yellow}&#x27; + util.toKb(sizes.build) + &#x27;{/yellow} raw&#x27; +
          (sizes.minifiedBuild ?
              &#x27;, {yellow}&#x27; + util.toKb(sizes.minifiedBuild) + &#x27;{/yellow} minified&#x27; +
              &#x27; and {yellow}&#x27; + util.toKb(sizes.gzippedMinifiedBuild) + &#x27;{/yellow} gzipped&#x27;
            : &#x27;&#x27;)
          + &#x27;\n&#x27;)

        LocalPackage.buildTree(ids, true, function (err, tree) {
          if (err) return callback(err)
          log.info(tree)
          callback()
        })
      }

    , calculateSizes = function (callback) {
        sizes.build = files.build.length

        if (!files.minifiedBuild) return callback()
        sizes.minifiedBuild = files.minifiedBuild.length

        zlib.gzip(files.minifiedBuild, function (err, data) {
          if (err) return callback(new CompressionError(err))

          sizes.gzippedMinifiedBuild = data.length
          callback()
        })
      }

    , loadFiles = function (callback) {
        if (files) return callback()

        var tasks = {}

        tasks.build = fs.readFile.bind(null, buildName, &#x27;utf-8&#x27;)

        if (options.minifier != &#x27;none&#x27;) {
          tasks.minifiedBuild = fs.readFile.bind(null, buildName.replace(/\.js$/, &#x27;.min.js&#x27;), &#x27;utf-8&#x27;)
        }

        async.parallel(tasks, function (err, _files) {
          if (err) return callback(new FilesystemError(err))
          files = _files
          callback()
        })
      }

    , loadOptions = function (callback) {
        // If we&#x27;re the main command, we need to load things from the build
        if (!buildName) {
          buildName = util.getInputFilenameFromOptions(options)
          options = null
        }

        if (options &#x26;&#x26; ids) return callback()

        // read &#x27;Build: ...&#x27; and &#x27;Packages: ...&#x27; from the head of the build file
        util.parseContext(buildName, function (err, context) {
          if (err) return callback(err)
          options = context.options

          if (!ids) ids = util.packageList(options)
          callback()
        })
      }

  if (arguments.length &#x3c; 3) {
    callback = log
    log = undefined
  }

  if (!log) return callback()

  async.series(
      [
          loadOptions
        , loadFiles
        , calculateSizes
        , finish
      ]
    , callback
  )
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


#!/usr/bin/env node

var main = require(&#x27;../lib/main&#x27;)
  , log  = require(&#x27;../lib/util&#x27;).defaultLogger

main.<span class="apidocCodeKeywordSpan">exec</span>(process.argv, log, function (err) {
  process.exit(err ? 1 : 0)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.local_package" id="apidoc.module.ender.local_package">module ender.local_package</a></h1>


    <h2>
        <a href="#apidoc.element.ender.local_package.local_package" id="apidoc.element.ender.local_package.local_package">
        function <span class="apidocSignatureSpan">ender.</span>local_package
        <span class="apidocSignatureSpan">(root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LocalPackage(root) {
  this.root = root

  // Memoize methods that hit the disk
  this.loadDescriptor = async.memoize(this.loadDescriptor.bind(this), unitaryHash)
  this.loadSources = async.memoize(this.loadSources.bind(this), unitaryHash)

  return this
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package.addPackageMapping" id="apidoc.element.ender.local_package.addPackageMapping">
        function <span class="apidocSignatureSpan">ender.local_package.</span>addPackageMapping
        <span class="apidocSignatureSpan">(id, root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addPackageMapping = function (id, root) {
  packageMappings[id] = root
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    repository.install(idsToInstall, function (err, receipts) {
      if (err) return callback(err) // wrapped in ender-repository

      // Unmemoize all the packages we just installed
      receipts.forEach(function (receipt) {
        installedIds.push(receipt.id)
        LocalPackage.unloadPackage(receipt.root)
        LocalPackage.<span class="apidocCodeKeywordSpan">addPackageMapping</span>(receipt.source, receipt.root)
      })

      callback(null, receipts)
    })
  }

, installRest = function (callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package.buildTree" id="apidoc.element.ender.local_package.buildTree">
        function <span class="apidocSignatureSpan">ender.local_package.</span>buildTree
        <span class="apidocSignatureSpan">(ids, pretty, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildTree = function (ids, pretty, callback) {
  var seenRoots = []

    , processId = function (id, root, callback) {
        LocalPackage.findPackage(id, root, function (err, dep) {
          if (err) return callback(err)
          processPackage(dep, callback)
        })
      }

    , processPackage = function (pkg, callback) {
        var node = {}
          , first = seenRoots.indexOf(pkg.root) == -1

        seenRoots.push(pkg.root)

        if (pretty) {
          if (first) {
            node.label = &#x27;{yellow}&#x27; + pkg.name + &#x27;@&#x27; + pkg.version + &#x27;{/yellow}{white} - &#x27; + pkg.description + &#x27;{/white}&#x27;
          } else {
            node.label = &#x27;{grey}&#x27; + pkg.name + &#x27;@&#x27; + pkg.version + &#x27; - &#x27; + pkg.description + &#x27;{/grey}&#x27;
          }
        } else {
          node.label = pkg.name + &#x27;@&#x27; + pkg.version
        }

        async.map(
            pkg.dependencies
          , function (id, callback) { processId(id, pkg.root, callback) }
          , function (err, nodes) {
            if (err) return callback(err)
            node.nodes = nodes
            callback(null, node)
          }
        )
      }

  async.map(
      ids
    , function (id, callback) { processId(id, &#x27;.&#x27;, callback) }
    , function (err, nodes) {
        if (err) return callback(err)

        var archyTree = {
                label: &#x27;Active packages:&#x27;
              , nodes: nodes
            }

        callback(null, archy(archyTree))
      }
  )
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      &#x27;Your current build size is: {yellow}&#x27; + util.toKb(sizes.build) + &#x27;{/yellow} raw&#x27; +
      (sizes.minifiedBuild ?
          &#x27;, {yellow}&#x27; + util.toKb(sizes.minifiedBuild) + &#x27;{/yellow} minified&#x27; +
          &#x27; and {yellow}&#x27; + util.toKb(sizes.gzippedMinifiedBuild) + &#x27;{/yellow} gzipped&#x27;
        : &#x27;&#x27;)
      + &#x27;\n&#x27;)

    LocalPackage.<span class="apidocCodeKeywordSpan">buildTree</span>(ids, true, function (err, tree) {
      if (err) return callback(err)
      log.info(tree)
      callback()
    })
  }

, calculateSizes = function (callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package.createPackage" id="apidoc.element.ender.local_package.createPackage">
        function <span class="apidocSignatureSpan">ender.local_package.</span>createPackage
        <span class="apidocSignatureSpan">(root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createPackage = function (root) {
  root = path.resolve(root)
  return packageCache[root] || (packageCache[root] = new LocalPackage(root))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
extend(LocalPackage, {
  createPackage: function (root) {
    root = path.resolve(root)
    return packageCache[root] || (packageCache[root] = new LocalPackage(root))
  }

, loadPackage: function (root, callback) {
    var pkg = LocalPackage.<span class="apidocCodeKeywordSpan">createPackage</span>(root)
    pkg.loadDescriptor(function (err) {
      if (err) return callback(err)
      callback(null, pkg)
    })
  }

, unloadPackage: function (root) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package.extendDescriptor" id="apidoc.element.ender.local_package.extendDescriptor">
        function <span class="apidocSignatureSpan">ender.local_package.</span>extendDescriptor
        <span class="apidocSignatureSpan">(descriptor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extendDescriptor = function (descriptor) {
  var overrides = [&#x27;bare&#x27;, &#x27;name&#x27;, &#x27;files&#x27;, &#x27;main&#x27;, &#x27;bridge&#x27;, &#x27;dependencies&#x27;, &#x27;devDependencies&#x27;]
    , newDescriptor = Object.create(descriptor) // original is available via Object.getPrototypeOf
    , key

  if (typeof descriptor.overlay == &#x27;object&#x27; &#x26;&#x26;
      typeof descriptor.overlay.ender == &#x27;object&#x27;) {
    overrides.forEach(function (key) {
      if (key in descriptor.overlay.ender) {
        newDescriptor[key] = descriptor.overlay.ender[key]
      }
    })
  }

  if (descriptor.ender == &#x27;noop&#x27;) {
    newDescriptor.ender = null

  } else if (typeof descriptor.ender == &#x27;string&#x27;) {
    newDescriptor.bridge = descriptor.ender

  } else if (typeof descriptor.ender == &#x27;object&#x27;) {
    overrides.forEach(function (key) {
      if (key in descriptor.ender) {
        newDescriptor[key] = descriptor.ender[key]
      }
    })
  }

  return newDescriptor
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  try {
    data = JSON.parse(data)
  } catch (err) {
    return callback(new JSONParseError(err.message + &#x27; [&#x27; + descriptorPath + &#x27;]&#x27;, err))
  }

  this.descriptor = LocalPackage.<span class="apidocCodeKeywordSpan">extendDescriptor</span>(data)
  this.name = this.descriptor.name
  this.version = this.descriptor.version || &#x27;&#x27;
  this.description = this.descriptor.description || &#x27;&#x27;
  this.bare = !!this.descriptor.bare

  callback()
}.bind(this))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package.findPackage" id="apidoc.element.ender.local_package.findPackage">
        function <span class="apidocSignatureSpan">ender.local_package.</span>findPackage
        <span class="apidocSignatureSpan">(id, root, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findPackage = function (id, root, callback) {
  var name = repository.util.getName(id)
    , version = repository.util.getVersion(id)
    , nameType = repository.util.getNameType(name)
    , matches = function (pkg) {
        return (pkg &#x26;&#x26;
                (nameType == &#x27;path&#x27; || pkg.originalName == name) &#x26;&#x26;
                semver.satisfies(pkg.version, version))
      }

  root = path.resolve(root)

  // See if we&#x27;ve mapped this package id to a local package
  if (id in packageMappings) {
    name = packageMappings[id]
    nameType = &#x27;path&#x27;
  }

  switch (nameType) {
    case &#x27;path&#x27;:
      LocalPackage.loadPackage(name, function (err, pkg) {
        if (matches(pkg)) return callback(null, pkg)
        return callback(new PackageNotFoundError(&#x22;Package at &#x27;&#x22; + name + &#x22;&#x27; does not satisfy version &#x27;&#x22; + version + &#x22;&#x27;.&#x22;))
      })
      break

    case &#x27;package&#x27;:
      // Don&#x27;t search above the CWD
      if (/^\.\./.test(path.relative(&#x27;.&#x27;, root)))
        return callback(new PackageNotFoundError(&#x22;Package &#x27;&#x22; + id + &#x22;&#x27; could not be found.&#x22;))

      LocalPackage.loadPackage(root, function (err, pkg) {
        if (matches(pkg)) return callback(null, pkg)

        LocalPackage.loadPackage(repository.util.getChildRoot(name, root), function (err, pkg) {
          if (matches(pkg)) return callback(null, pkg)

          LocalPackage.findPackage(id, path.dirname(root), callback)
        })
      })
      break

    case &#x27;tarball&#x27;:
    case &#x27;url&#x27;:
    case &#x27;git&#x27;:
    case &#x27;github&#x27;:
      callback(new PackageNotLocalError(&#x27;Can only find packages by path or name&#x27;))
      break
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  LocalPackage.loadPackage(root, function (err, pkg) {
    if (matches(pkg)) return callback(null, pkg)

    LocalPackage.loadPackage(repository.util.getChildRoot(name, root), function (err, pkg) {
      if (matches(pkg)) return callback(null, pkg)

      LocalPackage.<span class="apidocCodeKeywordSpan">findPackage</span>(id, path.dirname(root), callback)
    })
  })
  break

case &#x27;tarball&#x27;:
case &#x27;url&#x27;:
case &#x27;git&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package.loadPackage" id="apidoc.element.ender.local_package.loadPackage">
        function <span class="apidocSignatureSpan">ender.local_package.</span>loadPackage
        <span class="apidocSignatureSpan">(root, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadPackage = function (root, callback) {
  var pkg = LocalPackage.createPackage(root)
  pkg.loadDescriptor(function (err) {
    if (err) return callback(err)
    callback(null, pkg)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      if (id in packageMappings) {
name = packageMappings[id]
nameType = &#x27;path&#x27;
      }

      switch (nameType) {
case &#x27;path&#x27;:
  LocalPackage.<span class="apidocCodeKeywordSpan">loadPackage</span>(name, function (err, pkg) {
    if (matches(pkg)) return callback(null, pkg)
    return callback(new PackageNotFoundError(&#x22;Package at &#x27;&#x22; + name + &#x22;&#x27; does not satisfy version &#x27;&#
x22; + version + &#x22;&#x27;.&#x22;))
  })
  break

case &#x27;package&#x27;:
  // Don&#x27;t search above the CWD
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package.unloadPackage" id="apidoc.element.ender.local_package.unloadPackage">
        function <span class="apidocSignatureSpan">ender.local_package.</span>unloadPackage
        <span class="apidocSignatureSpan">(root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unloadPackage = function (root) {
  LocalPackage.createPackage(root).unload()

  for (var key in packageMappings)
    if (packageMappings[key] == root)
      delete packageMappings[key]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        , install = function (idsToInstall, callback) {
  repository.install(idsToInstall, function (err, receipts) {
    if (err) return callback(err) // wrapped in ender-repository

    // Unmemoize all the packages we just installed
    receipts.forEach(function (receipt) {
      installedIds.push(receipt.id)
      LocalPackage.<span class="apidocCodeKeywordSpan">unloadPackage</span>(receipt.root)
      LocalPackage.addPackageMapping(receipt.source, receipt.root)
    })

    callback(null, receipts)
  })
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package.walkDependencies" id="apidoc.element.ender.local_package.walkDependencies">
        function <span class="apidocSignatureSpan">ender.local_package.</span>walkDependencies
        <span class="apidocSignatureSpan">(ids, unique, strict, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">walkDependencies = function (ids, unique, strict, callback) {
  var packages = []
    , missing = []
    , seenNames = []
    , seenRoots = []

    , processId = function (id, root, callback) {
        LocalPackage.findPackage(id, root, function (err, pkg) {
          if (err) {
            if (strict) return callback(err)

            missing.push(id)
            return callback()
          }

          processPackage(pkg, callback)
        })
      }

    , processPackage = function (pkg, callback) {
        if (seenRoots.indexOf(pkg.root) != -1) return callback()
        seenRoots.push(pkg.root)

        async.map(
            pkg.dependencies
          , function (id, callback) { processId(id, pkg.root, callback) }
          , function (err) {
              if (err) return callback(err)
              packages.push(pkg)
              seenNames.push(pkg.originalName)
              callback()
          }
        )
      }

  async.map(
      ids
    , function (id, callback) { processId(id, &#x27;.&#x27;, callback) }
    , function (err) {
        if (err) return callback(err)

        if (unique) {
          // Return only the first package if we found multiple instances
          packages = packages.filter(function (p, i) { return seenNames.indexOf(p.originalName) == i })
          missing = missing.filter(function (n, i) { return missing.indexOf(n) == i })
        }

        callback(null, packages, missing)
      }
  )
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    })
  }
, callback
            )
          }

        , updateMissing = function (callback) {
            LocalPackage.<span class="apidocCodeKeywordSpan">walkDependencies</span>(ids, true, false, function (err, packages,
_missing) {
if (err) return callback(err) // this should never happen if we don&#x27;t request `strict`

missing = _missing
var dupes = missing.filter(function (id) { return installedIds.indexOf(id) != -1 })
if (dupes.length)
  return callback(new DependencyLoopError(&#x27;Installing identical package twice: &#x27; + dupes))
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.local_package.prototype" id="apidoc.module.ender.local_package.prototype">module ender.local_package.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ender.local_package.prototype.extendOptions" id="apidoc.element.ender.local_package.prototype.extendOptions">
        function <span class="apidocSignatureSpan">ender.local_package.prototype.</span>extendOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extendOptions = function (options) {
  var externs = this.descriptor &#x26;&#x26; this.descriptor.externs
    , root = this.root

  if (externs) {
    if (!Array.isArray(externs)) externs = [ externs ]
    if (!options.externs) options.externs = []
    options.externs = options.externs.concat(externs.map(function (e) {
      return path.join(root, e)
    }))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (options.minifier == &#x27;none&#x27;) return callback(null, files)

    var minifier = minifiers[options.minifier || &#x27;uglify&#x27;]
      , extendedOptions = extend({}, options)

    if (!minifier) return new MinifyError(&#x27;No such minifier: &#x22;&#x27; + options.minifier + &#x27;&#x22;&#x27;)

    packages.forEach(function (pkg) { pkg.<span class="apidocCodeKeywordSpan">extendOptions</span>(extendedOptions) })
    minifier(files, filenames, extendedOptions, callback)
  }

, assembleBuild = function (callback) {
    assemble.assemble(filenames.build, filenames.sourceMap, options, packages, callback)
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package.prototype.loadDescriptor" id="apidoc.element.ender.local_package.prototype.loadDescriptor">
        function <span class="apidocSignatureSpan">ender.local_package.prototype.</span>loadDescriptor
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadDescriptor = function (callback) {
  var descriptorPath = repository.util.getPackageDescriptor(this.root)

  fs.readFile(descriptorPath, &#x27;utf-8&#x27;, function (err, data) {
    if (err) return callback(new FilesystemError(err))

    try {
      data = JSON.parse(data)
    } catch (err) {
      return callback(new JSONParseError(err.message + &#x27; [&#x27; + descriptorPath + &#x27;]&#x27;, err))
    }

    this.descriptor = LocalPackage.extendDescriptor(data)
    this.name = this.descriptor.name
    this.version = this.descriptor.version || &#x27;&#x27;
    this.description = this.descriptor.description || &#x27;&#x27;
    this.bare = !!this.descriptor.bare

    callback()
  }.bind(this))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  createPackage: function (root) {
    root = path.resolve(root)
    return packageCache[root] || (packageCache[root] = new LocalPackage(root))
  }

, loadPackage: function (root, callback) {
    var pkg = LocalPackage.createPackage(root)
    pkg.<span class="apidocCodeKeywordSpan">loadDescriptor</span>(function (err) {
      if (err) return callback(err)
      callback(null, pkg)
    })
  }

, unloadPackage: function (root) {
    LocalPackage.createPackage(root).unload()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package.prototype.loadSources" id="apidoc.element.ender.local_package.prototype.loadSources">
        function <span class="apidocSignatureSpan">ender.local_package.prototype.</span>loadSources
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadSources = function (callback) {
  var loadFile = async.memoize(function (file, callback) {
        file = path.normalize(file)
        fs.readFile(path.join(this.root, file), &#x27;utf-8&#x27;, function (err, content) {
          if (err) return callback(new FilesystemError(err))
          callback(null, { name: file.replace(/(\.js)?$/, &#x27;&#x27;), content: content })
        })
      }.bind(this))

    , expandGlob = async.memoize(function (file, callback) {
        // use glob.Glob because it&#x27;s easier to stub for tests
        new glob.Glob(file, { cwd: this.root, root: this.root, nomount: true }, function (err, files) {
          if (err) return callback(new FilesystemError(err))
          callback(null, files)
        })
      }.bind(this))

    , expandDirectory = async.memoize(function (file, callback) {
        fs.stat(path.join(this.root, file), function (err, stats) {
          if (err) return callback(new FilesystemError(err))
          if (!stats.isDirectory()) return callback(null, [ file ])

          fs.readdir(path.join(this.root, file), function (err, names) {
            if (err) return callback(new FilesystemError(err))

            var files = names.map(function (name) { return path.join(file, name) })
            async.concat(files, expandDirectory, callback)
          })
        }.bind(this))
      }.bind(this))

    , contractDirectory = async.memoize(function (file, callback) {
        fs.stat(path.join(this.root, file), function (err, stats) {
          if (err) return callback(new FilesystemError(err))
          if (stats.isDirectory()) return callback(null, [])
          return callback(null, [ file ])
        }.bind(this))
      }.bind(this))

    , loadModule = function (name, callback) {
        var files = this.descriptor[name] || []
        if (typeof files == &#x27;string&#x27;) files = [ files ]
        if (!Array.isArray(files)) files = files[&#x27;scripts&#x27;] || []

        if (name == &#x27;main&#x27; &#x26;&#x26; !files.length) {
          // default to index as the main module
          files = [ &#x27;index&#x27;, &#x27;index.js&#x27; ]
        } else {
          // add additional search paths
          files = files.concat(files.map(function (file) { return file + &#x27;.js&#x27; }),
                               files.map(function (file) { return path.join(file, &#x27;index.js&#x27;) }))
        }

        async.waterfall([
            function (callback)          { async.concat(files, expandGlob, callback) }
          , function (files, callback)   { async.concat(files, contractDirectory, callback) }
          , function (files, callback)   { async.map(files, loadFile, callback) }
          , function (sources, callback) {
              if (sources.length &#x3e; 1) {
                // If we have an array of files, combine them into one file
                sources = [{
                    name: name
                  , content: sources.map(function (s) { return s.content }).join(&#x27;\n\n&#x27;)
                }]
              }

              callback(null, sources)
            }
        ], callback)
      }.bind(this)

    , loadFiles = function (callback) {
        var files = this.descriptor.files || []
        if (typeof files == &#x27;string&#x27;) files = [ files ]
        if (!Array.isArray(files)) files = files[&#x27;scripts&#x27;] || []

        async.waterfall([
            function (callback)        { async.concat(files, expandGlob, callback) }
          , function (files, callback) { async.concat(files, expandDirectory, callback) }
          , function (files, callback) { callback(null, files.filter(function (f) { return /\.js$/.test(f) }).sort()) }
          , function (files, callback) { async.map(files, loadFile, callback) }
        ], callback)
      }.bind(this)

  async.parallel(
    {
        main:   loadModule.bind(null, &#x27;main&#x27;)
      , bridge: loadModule.bind(null, &#x27;bridge&#x27;)
      , files:  loadFiles
    },
    function (err, results) {
      if (err) return callback(err)

      // concat the results and filter duplicates (this works on objects because loadFile is memoized)
      this.sources = [].concat(results.main, results.bridge, results.files)
      this.sources = this.sources.filter(f ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

  , assembleBuild = function (callback) {
      assemble.assemble(filenames.build, filenames.sourceMap, options, packages, callback)
    }

  , loadSources = function (callback) {
      async.each(packages, function (pkg, callback) { pkg.<span class="apidocCodeKeywordSpan">loadSources</span>(callback) }, callback
)
    }

async.waterfall([
    loadSources
  , assembleBuild
  , minifyBuild
  , writeFiles
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.local_package.prototype.unload" id="apidoc.element.ender.local_package.prototype.unload">
        function <span class="apidocSignatureSpan">ender.local_package.prototype.</span>unload
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unload = function () {
  delete this.loadDescriptor.memo._
  delete this.loadSources.memo._
  delete this.descriptor
  delete this.sources
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    pkg.loadDescriptor(function (err) {
      if (err) return callback(err)
      callback(null, pkg)
    })
  }

, unloadPackage: function (root) {
    LocalPackage.createPackage(root).<span class="apidocCodeKeywordSpan">unload</span>()

    for (var key in packageMappings)
      if (packageMappings[key] == root)
        delete packageMappings[key]
  }

, addPackageMapping: function (id, root) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.refresh" id="apidoc.module.ender.refresh">module ender.refresh</a></h1>


    <h2>
        <a href="#apidoc.element.ender.refresh.exec" id="apidoc.element.ender.refresh.exec">
        function <span class="apidocSignatureSpan">ender.refresh.</span>exec
        <span class="apidocSignatureSpan">(options, log, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (options, log, callback) {
  var filename = util.getInputFilenameFromOptions(options)
; delete options.use // don&#x27;t want --use showing up in the &#x27;Build:&#x27; context string
  util.parseContext(filename, function (err, context) {
    if (err) return callback(err)

    // set --force-install but don&#x27;t leave a trace in the &#x27;Build:&#x27; context string
    context.options[&#x27;_force-install&#x27;] = true
    build.exec(context.options, log, callback)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


#!/usr/bin/env node

var main = require(&#x27;../lib/main&#x27;)
  , log  = require(&#x27;../lib/util&#x27;).defaultLogger

main.<span class="apidocCodeKeywordSpan">exec</span>(process.argv, log, function (err) {
  process.exit(err ? 1 : 0)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.remove" id="apidoc.module.ender.remove">module ender.remove</a></h1>


    <h2>
        <a href="#apidoc.element.ender.remove.exec" id="apidoc.element.ender.remove.exec">
        function <span class="apidocSignatureSpan">ender.remove.</span>exec
        <span class="apidocSignatureSpan">(options, log, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (options, log, callback) {
  var filename = util.getInputFilenameFromOptions(options)
    , toRemove = options.packages
    , finish   = function (err) {
        repository.packup(err)
        callback(err)
      }

; delete options.use // don&#x27;t want --use showing up in the &#x27;Build:&#x27; context string
  options.packages = [] // reset the packages list so argsParser.extend() doesn&#x27;t include them

  util.parseContext(filename, function (err, context) {
    if (err) return callback(err)

    // merge the commandline with the ender.js build command
    options          = argsParser.extend(context.options, options)
    options.packages = options.packages.filter(function (p) {
      return toRemove.indexOf(p) == -1 // do the remove!
    })

    async.series(
        [
            repository.setup // shouldn&#x27;t need to do a packup because main-build will do it
          , repository.uninstall.bind(null, toRemove)
          , build.exec.bind(null, options, log) // hard work done by main-build
        ]
      , finish
    )
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


#!/usr/bin/env node

var main = require(&#x27;../lib/main&#x27;)
  , log  = require(&#x27;../lib/util&#x27;).defaultLogger

main.<span class="apidocCodeKeywordSpan">exec</span>(process.argv, log, function (err) {
  process.exit(err ? 1 : 0)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.search" id="apidoc.module.ender.search">module ender.search</a></h1>


    <h2>
        <a href="#apidoc.element.ender.search.exec" id="apidoc.element.ender.search.exec">
        function <span class="apidocSignatureSpan">ender.search.</span>exec
        <span class="apidocSignatureSpan">(options, log, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (options, log, callback) {
  var terms   = options.packages
    , max     = options.max || defaultMax
    , handler = handle.bind(null, terms, max, log, callback)

  if (arguments.length &#x3c; 3) {
    callback = log
    log = undefined
  }

  if (!log) return callback()

  log.info(&#x27;Searching NPM registry...&#x27;)

  repository.setup(function (err) {
    if (err) return callback(err) // wrapped in repository.js
    repository.search(terms, handler)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


#!/usr/bin/env node

var main = require(&#x27;../lib/main&#x27;)
  , log  = require(&#x27;../lib/util&#x27;).defaultLogger

main.<span class="apidocCodeKeywordSpan">exec</span>(process.argv, log, function (err) {
  process.exit(err ? 1 : 0)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.util" id="apidoc.module.ender.util">module ender.util</a></h1>


    <h2>
        <a href="#apidoc.element.ender.util.getCorePackages" id="apidoc.element.ender.util.getCorePackages">
        function <span class="apidocSignatureSpan">ender.util.</span>getCorePackages
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCorePackages = function (options) {
  var corePackages = []

  if (options[&#x27;client-lib&#x27;] != &#x27;none&#x27;)
    corePackages.push(options[&#x27;client-lib&#x27;] || defaultClientLib)

  if (options[&#x27;module-lib&#x27;] != &#x27;none&#x27;)
    corePackages.push(options[&#x27;module-lib&#x27;] || defaultModuleLib)

  return corePackages
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          , [ &#x27;ender-core&#x27;, &#x27;ender-commonjs&#x27;, &#x27;apkg&#x27;, &#x27;pkg2&#x27;, &#x27;pkg3&#x27;, &#x27;.&#
x27;, &#x27;..&#x27; ]
        )
      }
  }

, &#x27;getCorePackages&#x27;: {
      &#x27;no args&#x27;: function () {
        assert.equals(util.<span class="apidocCodeKeywordSpan">getCorePackages</span>({}), [&#x27;ender-core&#x27;, &#x27;ender-
commonjs&#x27;])
      }
  }

, &#x27;parseContext&#x27;: {
      &#x27;test simple old-skool parse&#x27;: function (done) {
        var content = &#x27;&#x27;
              + &#x27;/*!\n&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.util.getInputFilenameFromOptions" id="apidoc.element.ender.util.getInputFilenameFromOptions">
        function <span class="apidocSignatureSpan">ender.util.</span>getInputFilenameFromOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getInputFilenameFromOptions = function (options) {
  return options.use ? options.use.replace(/(\.js)?$/, &#x27;.js&#x27;) : &#x27;ender.js&#x27;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */

var argsParser   = require(&#x27;../args-parser&#x27;)
, util         = require(&#x27;../util&#x27;)
, build        = require(&#x27;./build&#x27;)

, exec = function (options, log, callback) {
    var filename = util.<span class="apidocCodeKeywordSpan">getInputFilenameFromOptions</span>(options)
  ; delete options.use // don&#x27;t want --use showing up in the &#x27;Build:&#x27; context string
    util.parseContext(filename, function (err, context) {
      if (!err) options = argsParser.extend(context.options, options)
      // merge commandline args with the build command in ender.js
      build.exec(options, log, callback)
    })
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.util.packageList" id="apidoc.element.ender.util.packageList">
        function <span class="apidocSignatureSpan">ender.util.</span>packageList
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">packageList = function (options) {
  var ids = options.packages &#x26;&#x26; options.packages.length ? options.packages : [ &#x27;.&#x27; ]
  return getCorePackages(options).concat(ids)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
], function (err, files) {
  if (err) return callback(err)
  callback(null, files, filenames)
})
    }

  , exec = function (options, log, callback) {
var ids = util.<span class="apidocCodeKeywordSpan">packageList</span>(options)
  , refresh = options[&#x27;force-install&#x27;] || options[&#x27;_force-install&#x27;]

if (arguments.length &#x3c; 3) {
  callback = log
  log = undefined
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.util.parseContext" id="apidoc.element.ender.util.parseContext">
        function <span class="apidocSignatureSpan">ender.util.</span>parseContext
        <span class="apidocSignatureSpan">(file, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseContext = function (file, callback) {
  fs.open(file, &#x27;r&#x27;, function (err, fd) {
    if (err) return callback(new FilesystemError(err))

    var buffer = new Buffer(2048)
    fs.read(fd, buffer, 0, 2048, null, function (err, bytesRead, buffer) {
      if (err) return callback(new FilesystemError(err))

      fs.close(fd, function () {
        // err? who cares, we have our data, let&#x27;s use it and run for the hills!
        var options
          , error
          , match = String(buffer).match(buildInfoRegex)

        if (!match) {
          error = &#x27;Could not parse ender spec from &#x22;&#x27; + file + &#x27;&#x22; (not an Ender build file?)&#x27;
          return callback(new BuildParseError(error))
        }

        try {
          options = argsParser.parseClean(match[1].split(&#x27; &#x27;))
        } catch (ex) {
          error = &#x27;Could not parse ender spec from &#x22;&#x27; + file + &#x27;&#x22;&#x27;
          return callback(new BuildParseError(error, ex))
        }

        callback(null, {
            options  : options
          , packages : match[2] &#x26;&#x26; match[2].split(&#x27; &#x27;)
        })
      })
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var argsParser   = require(&#x27;../args-parser&#x27;)
  , util         = require(&#x27;../util&#x27;)
  , build        = require(&#x27;./build&#x27;)

  , exec = function (options, log, callback) {
      var filename = util.getInputFilenameFromOptions(options)
    ; delete options.use // don&#x27;t want --use showing up in the &#x27;Build:&#x27; context string
      util.<span class="apidocCodeKeywordSpan">parseContext</span>(filename, function (err, context) {
        if (!err) options = argsParser.extend(context.options, options)
        // merge commandline args with the build command in ender.js
        build.exec(options, log, callback)
      })
    }

module.exports.exec = exec
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.util.toKb" id="apidoc.element.ender.util.toKb">
        function <span class="apidocSignatureSpan">ender.util.</span>toKb
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toKb = function (size) {
  size = Math.round(size / 1024 * 10) / 10
  return size + &#x27; kB&#x27;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    , function (raw, callback) {
        zlib.gzip(raw, function (err, gzipped) {
          if (err) return callback(new CompressionError(err))
          callback(null, raw, gzipped)
        })
      }
    , function (raw, gzipped, callback) {
        if (log) log.info(&#x27;Success! Your compiled source is {cyan}&#x27; + util.<span class="apidocCodeKeywordSpan">toKb</span
>(raw.length) + &#x27;{/cyan} minified&#x27; +
                          &#x27; and {cyan}&#x27; + util.toKb(gzipped.length) + &#x27;{/cyan} gzipped&#x27; +
                          &#x27; and is available at {green}&#x27; + outfile.green + &#x27;{/green}&#x27;)

        callback()
      }
  ], callback)
}
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.version" id="apidoc.module.ender.version">module ender.version</a></h1>


    <h2>
        <a href="#apidoc.element.ender.version.exec" id="apidoc.element.ender.version.exec">
        function <span class="apidocSignatureSpan">ender.version.</span>exec
        <span class="apidocSignatureSpan">(options, log, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (options, log, callback) {
  var file = path.resolve(__dirname, &#x27;..&#x27;, &#x27;..&#x27;, &#x27;package.json&#x27;)

  if (arguments.length &#x3c; 3) {
    callback = log
    log = undefined
  }

  if (!log) return callback()

  fs.readFile(file, &#x27;utf-8&#x27;, function (err, data) {
    if (err) return callback(new FilesystemError(err))
    try {
      data = JSON.parse(data)
    } catch (err) {
      return callback(new JSONParseError(err.message + &#x27; [&#x27; + file + &#x27;]&#x27;, err))
    }

    log.info(&#x27;Active version: v&#x27; + data.version)
    callback()
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


#!/usr/bin/env node

var main = require(&#x27;../lib/main&#x27;)
  , log  = require(&#x27;../lib/util&#x27;).defaultLogger

main.<span class="apidocCodeKeywordSpan">exec</span>(process.argv, log, function (err) {
  process.exit(err ? 1 : 0)
})
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ender.vlq" id="apidoc.module.ender.vlq">module ender.vlq</a></h1>


    <h2>
        <a href="#apidoc.element.ender.vlq.decode" id="apidoc.element.ender.vlq.decode">
        function <span class="apidocSignatureSpan">ender.vlq.</span>decode
        <span class="apidocSignatureSpan">(vlqstr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function (vlqstr) {
  var result = 0
    , digit
    , continuation
    , i

  for (i = 0, continuation = 1; continuation &#x26;&#x26; i &#x3c; vlqstr.length; i++) {
    digit = b64toi[vlqstr[i]]
    continuation = digit &#x26; VLQ_BASE    // Get the continuation bit
    digit &#x26;= VLQ_MASK                  // Mask off the continuation bit
    result += digit &#x3c;&#x3c; (VLQ_BITS * i)  // Add the digit to the result
  }

  if (continuation &#x26;&#x26; i == vlqstr.length) return NaN
  return { value: fromVLQ(result), rest: vlqstr.slice(i) }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ender.vlq.encode" id="apidoc.element.ender.vlq.encode">
        function <span class="apidocSignatureSpan">ender.vlq.</span>encode
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encode = function (val) {
  var result = &#x27;&#x27;
    , vlq = toVLQ(val)
    , digit

  do {
    digit = vlq &#x26; VLQ_MASK      // Get the digit
    vlq &#x3e;&#x3e;&#x3e;= VLQ_BITS           // Shift off the digit
    if (vlq) digit |= VLQ_BASE  // Set the continuation bit
    result += itob64[digit]
  } while (vlq &#x3e; 0)

  return result
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (!line.length) return &#x27;&#x27;

    sourceIndex += sourceIndexDelta
    sourceLine += sourceLineDelta

    return (
      vlq.<span class="apidocCodeKeywordSpan">encode</span>(indent || 0) +                                     // Adjust for indent
      vlq.encode(sourceIndexDelta) +                                // Set the source index
      vlq.encode(sourceLineDelta) +                                 // Set the source line
      vlq.encode(0) +                                               // Source column (always 0)
      (ending ? &#x27;;&#x27; : &#x27;&#x27;)                                           // Did we have a line ending?
    )
  })
}
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
